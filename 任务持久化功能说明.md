# 任务持久化功能说明

## 问题描述

**症状**: 服务器重启后，用户提示"任务不存在"

**原因**: 
- 之前使用内存存储任务数据（`processing_tasks = {}`）
- Render服务器重启后，内存被清空
- 所有已完成的任务数据丢失
- 用户无法导出之前处理的结果

## 解决方案

### 任务持久化机制

实现了一个简单但有效的文件系统持久化方案：

1. **任务完成时自动保存到磁盘**
   - 位置：`tasks/{task_id}.json`
   - 格式：JSON
   - 内容：完整的任务数据和处理结果

2. **访问任务时自动加载**
   - 先检查内存缓存
   - 如果不存在，从磁盘加载
   - 加载后放入内存缓存

3. **双层存储架构**
   ```
   内存缓存 (快速访问)
        ↓
   磁盘存储 (持久化)
   ```

## 技术实现

### 1. 保存任务到磁盘

```python
def save_task_to_disk(task_id: str, task_data: dict) -> None:
    """Save task data to disk for persistence"""
    task_file = os.path.join(TASKS_FOLDER, f"{task_id}.json")
    
    # Convert result object to dict
    # ... (序列化处理)
    
    with open(task_file, 'w', encoding='utf-8') as f:
        json.dump(task_data_copy, f, ensure_ascii=False, indent=2)
```

**调用时机**:
- 任务成功完成时
- 任务失败时

### 2. 从磁盘加载任务

```python
def load_task_from_disk(task_id: str) -> dict:
    """Load task data from disk"""
    task_file = os.path.join(TASKS_FOLDER, f"{task_id}.json")
    
    if os.path.exists(task_file):
        with open(task_file, 'r', encoding='utf-8') as f:
            task_data = json.load(f)
        
        # Convert dict back to result object
        # ... (反序列化处理)
        
        return task_data
    
    return None
```

**调用时机**:
- 访问任务状态时
- 获取任务结果时
- 导出任务结果时
- 查看任务报告时

### 3. 统一的任务访问模式

所有任务访问函数都使用相同的模式：

```python
# Try to get from memory first
if task_id not in processing_tasks:
    # Try to load from disk
    task_data = load_task_from_disk(task_id)
    if task_data:
        processing_tasks[task_id] = task_data
    else:
        return create_response(
            error="任务不存在",
            status_code=404
        )

task = processing_tasks[task_id]
```

## 文件结构

```
project/
├── tasks/                    # 任务数据目录
│   ├── .gitkeep             # 确保目录被git跟踪
│   ├── task_file1_Sheet1.json
│   ├── task_file2_Sheet1.json
│   └── ...
├── uploads/                  # 上传文件目录
└── output/                   # 导出文件目录
```

## 任务文件格式

```json
{
  "status": "completed",
  "progress": 100,
  "message": "处理完成",
  "file_id": "20260116_120000_test.xlsx",
  "sheet_name": "Sheet1",
  "result": {
    "total_cells_processed": 10,
    "total_claims_extracted": 5,
    "language_distribution": {
      "zh": 3,
      "en": 2
    },
    "independent_claims_count": 2,
    "dependent_claims_count": 3,
    "claims_data": [
      {
        "claim_number": 1,
        "claim_type": "independent",
        "claim_text": "...",
        "language": "zh",
        "referenced_claims": [],
        "original_text": "...",
        "confidence_score": 0.95
      }
    ],
    "processing_errors": []
  }
}
```

## 优势

### 1. 持久化
- ✅ 服务器重启后任务仍然可用
- ✅ 用户可以随时访问历史任务
- ✅ 不依赖外部数据库

### 2. 性能
- ✅ 内存缓存提供快速访问
- ✅ 只在需要时从磁盘加载
- ✅ 避免重复读取磁盘

### 3. 简单
- ✅ 不需要额外的数据库
- ✅ 易于调试和维护
- ✅ 文件格式人类可读

### 4. 可靠
- ✅ 自动错误处理
- ✅ 失败任务也会保存
- ✅ 不影响主流程

## 使用场景

### 场景1: 正常使用
1. 用户上传文件并处理
2. 任务完成，自动保存到磁盘
3. 用户导出结果
4. 从内存缓存快速获取

### 场景2: 服务器重启
1. 用户之前处理过文件
2. 服务器重启，内存清空
3. 用户尝试导出结果
4. 系统从磁盘加载任务
5. 导出成功

### 场景3: 多次访问
1. 用户处理文件
2. 第一次导出：从内存获取
3. 服务器重启
4. 第二次导出：从磁盘加载
5. 第三次导出：从内存缓存获取

## 限制和注意事项

### 1. 存储空间
- 每个任务文件约几KB到几MB
- 需要定期清理旧任务文件
- 建议保留最近30天的任务

### 2. 并发访问
- 当前实现不支持分布式部署
- 单服务器实例工作良好
- 多实例需要共享存储

### 3. 文件系统
- 依赖文件系统的可靠性
- Render提供持久化存储
- 不适合频繁读写的场景

## 未来改进

### 短期（1-2周）
- [ ] 添加任务过期机制
- [ ] 自动清理旧任务文件
- [ ] 添加任务列表API

### 中期（1-2月）
- [ ] 实现任务压缩存储
- [ ] 添加任务搜索功能
- [ ] 支持任务导入导出

### 长期（3-6月）
- [ ] 迁移到Redis
- [ ] 支持分布式部署
- [ ] 实现任务队列

## 监控和维护

### 检查任务文件

```bash
# 查看任务文件数量
ls -l tasks/*.json | wc -l

# 查看任务文件大小
du -sh tasks/

# 查看最近的任务
ls -lt tasks/*.json | head -10
```

### 清理旧任务

```bash
# 删除30天前的任务文件
find tasks/ -name "*.json" -mtime +30 -delete
```

### 备份任务数据

```bash
# 备份所有任务
tar -czf tasks_backup_$(date +%Y%m%d).tar.gz tasks/
```

## 部署状态

**提交信息**:
- 提交哈希: 9e686b7
- 提交时间: 2026年1月16日
- 状态: ✅ 已推送到GitHub

**Render部署**:
- 状态: ⏳ 自动部署中
- 预计时间: 5-7分钟

## 验证步骤

部署完成后：

1. **处理一个文件**
   - 上传并处理权利要求文件
   - 等待处理完成

2. **导出结果**
   - 点击导出Excel
   - 确认文件可以下载和打开

3. **模拟重启**
   - 等待几分钟（Render可能自动重启）
   - 或者手动触发重启

4. **再次导出**
   - 刷新页面
   - 再次点击导出
   - ✅ 应该仍然可以导出

## 总结

通过实现任务持久化功能，解决了服务器重启后任务丢失的问题。用户现在可以：

- ✅ 在服务器重启后继续访问任务
- ✅ 随时导出之前处理的结果
- ✅ 不需要重新处理文件

这是一个简单但有效的解决方案，适合当前的应用规模和部署环境。

---

**创建时间**: 2026年1月16日  
**版本**: v1.3.0  
**状态**: 已部署
