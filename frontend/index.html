<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>专利分析智能工作台 v26</title>
    
    <!-- 早期主题检测 - 必须在CSS加载前执行 -->
    <script>
    (function() {
        var savedTheme = localStorage.getItem('patent-workbench-theme');
        if (savedTheme === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
        }
    })();
    </script>
    
    <!-- 预连接优化 -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    
    <!-- 首屏关键CSS内联 -->
    <style>
        /* 关键渲染路径CSS - 最小化首屏样式 */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            min-height: 100vh;
            position: relative;
        }
        #vanta-bg { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: -1; pointer-events: none; 
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 50%, #d1fae5 100%);
        }
        .container { 
            max-width: 1600px; margin: 0 auto; padding: 20px;
            position: relative; z-index: 1;
        }
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 99999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease-out, visibility 0.8s ease-out;
            overflow: hidden;
        }
        .loading-overlay.hidden { 
            opacity: 0; 
            visibility: hidden;
            pointer-events: none; 
        }
        #loading-vanta-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 50%, #d1fae5 100%);
        }
        .loading-content {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: relative; z-index: 2;
        }
        .tech-welcome-container {
            position: relative;
            padding: 30px 50px;
            margin-bottom: 40px;
            text-align: center;
            overflow: hidden;
        }
        .tech-scan-line {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #22c55e, #10b981, transparent);
            animation: scanLine 2s linear infinite;
        }
        @keyframes scanLine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        .tech-welcome-title {
            font-family: 'Orbitron', 'Noto Sans SC', monospace;
            font-size: 42px;
            font-weight: 900;
            color: #166534;
            text-shadow: 0 2px 10px rgba(34, 197, 94, 0.3);
            letter-spacing: 8px;
            margin-bottom: 15px;
            position: relative;
        }
        .tech-cursor {
            animation: cursorBlink 0.8s step-end infinite;
            color: #10b981;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        .tech-welcome-subtitle {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: #64748b;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.8;
        }
        .tech-loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(34, 197, 94, 0.15);
            border-radius: 2px;
            margin-top: 25px;
            overflow: hidden;
            position: relative;
        }
        .tech-loading-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.3), transparent);
            animation: loadingShimmer 1.5s infinite;
        }
        @keyframes loadingShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .tech-loading-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #22c55e, #10b981);
            border-radius: 2px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        .loading-spinner-container {
            position: relative;
            width: 80px;
            height: 80px;
            margin-bottom: 30px;
        }
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 3px solid rgba(34, 197, 94, 0.15);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-spinner-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 65px;
            height: 65px;
            border: 2px solid transparent;
            border-top-color: #10b981;
            border-right-color: #10b981;
            border-radius: 50%;
            animation: spinReverse 1.5s linear infinite;
        }
        .loading-spinner-ring.ring-2 {
            width: 80px;
            height: 80px;
            border: 1px solid transparent;
            border-bottom-color: rgba(34, 197, 94, 0.3);
            border-left-color: rgba(34, 197, 94, 0.3);
            animation: spin 2s linear infinite;
        }
        @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
        @keyframes spinReverse { to { transform: translate(-50%, -50%) rotate(-360deg); } }
        .loading-text { 
            color: #475569; 
            font-size: 14px; 
            font-family: 'Noto Sans SC', sans-serif;
            letter-spacing: 2px;
        }
        .loading-progress { 
            margin-top: 10px; 
            color: #94a3b8; 
            font-size: 12px;
            font-family: 'Orbitron', monospace;
            letter-spacing: 1px;
        }
        
        /* 骨架屏样式 */
        .skeleton {
            background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%);
            background-size: 200% 100%; animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* 悬浮二维码样式 */
        .floating-qr-container {
            position: fixed !important;
            right: 20px !important;
            bottom: 20px !important;
            z-index: 99999 !important;
            font-family: 'Noto Sans SC', sans-serif;
        }
        .floating-qr-toggle {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #22C55E, #16A34A);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
            transition: all 0.3s ease;
            color: white;
        }
        .floating-qr-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
        }
        .floating-qr-panel {
            position: absolute;
            right: 60px;
            bottom: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            width: 200px;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transform: translateX(20px);
            transition: all 0.3s ease;
        }
        .floating-qr-panel.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        .floating-qr-header {
            background: linear-gradient(135deg, #22C55E, #16A34A);
            color: white;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            font-size: 14px;
        }
        .floating-qr-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
        }
        .floating-qr-close:hover { opacity: 1; }
        .floating-qr-content {
            padding: 15px;
            text-align: center;
        }
        .floating-qr-content img {
            width: 130px;
            height: 130px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .floating-qr-title {
            margin: 10px 0 4px;
            font-weight: 600;
            color: #166534;
            font-size: 15px;
        }
        .floating-qr-desc {
            color: #666;
            font-size: 12px;
            margin: 0;
        }
        .floating-qr-tip {
            color: #999;
            font-size: 11px;
            margin: 8px 0 0;
            padding-top: 8px;
            border-top: 1px solid #f0f0f0;
        }
        @media (max-width: 768px) {
            .floating-qr-container {
                right: 15px !important;
                bottom: 15px !important;
            }
            .floating-qr-toggle {
                width: 44px;
                height: 44px;
            }
            .floating-qr-toggle svg {
                width: 20px;
                height: 20px;
            }
            .floating-qr-panel {
                right: 54px;
                width: 180px;
            }
            .floating-qr-content img {
                width: 110px;
                height: 110px;
            }
        }
    </style>
    
    <!-- 字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- Vanta.js Dependencies - 加载页面需要同步加载 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
    
    <!-- 模块化CSS文件 -->
    <link rel="stylesheet" href="frontend/css/main.css?v=20260207d">
    <link rel="stylesheet" href="frontend/css/pages/claims.css?v=20260207d">
    <link rel="stylesheet" href="frontend/css/pages/family-claims-comparison.css?v=20260207d">
    <!-- 功能六增强CSS -->
    <link rel="stylesheet" href="frontend/css/components/patent-template.css">
    <link rel="stylesheet" href="frontend/css/components/patent-chat.css">
    <link rel="stylesheet" href="frontend/css/components/patent-config.css">
    <link rel="stylesheet" href="frontend/css/components/patent-timeline.css">
    <link rel="stylesheet" href="frontend/css/components/field-selector.css">
    <!-- AI说明书处理器CSS -->
    <link rel="stylesheet" href="frontend/css/components/ai-description-processor.css">
    <!-- 功能九：PDF-OCR阅读器CSS -->
    <link rel="stylesheet" href="frontend/css/components/pdf-ocr-reader.css">
    <!-- 功能九：PDF-OCR交互功能CSS -->
    <link rel="stylesheet" href="frontend/css/components/pdf-ocr-interaction.css">
    <!-- 暗夜模式CSS -->
    <link rel="stylesheet" href="frontend/css/base/dark-theme.css?v=20260227">

        <style>
            /* Vanta.js 背景容器 */
            #vanta-bg {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: -1;
                pointer-events: none;
            }
            
            /* 确保主容器有透明背景 */
            body {
                position: relative;
            }
            
            .container {
                position: relative;
                z-index: 1;
            }
            
            .preset-badge {
                display: inline-block;
                padding: 2px 6px;
                background-color: #4a6cf7;
                color: white;
                border-radius: 4px;
                font-size: 0.75em;
                margin-left: 6px;
                vertical-align: middle;
            }
        
        /* 功能七子标签页样式 */
        .claims-sub-tab {
            display: none;
        }
        .claims-sub-tab.active {
            display: block;
        }
        
        /* 权利要求项样式 */
        .claim-item {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--border-color);
            transition: all 0.3s;
        }
        
        .claim-item.independent {
            background: linear-gradient(90deg, rgba(74, 108, 247, 0.1), rgba(74, 108, 247, 0.05));
            border-left-color: var(--primary-color);
        }
        
        .claim-item.dependent {
            background: rgba(128, 128, 128, 0.05);
            border-left-color: #999;
            color: #666;
        }
        
        .claim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .claim-number {
            font-weight: 700;
            font-size: 1.1em;
        }
        
        .claim-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
        }
        
        .claim-badge.independent {
            background: var(--primary-color);
            color: white;
        }
        
        .claim-badge.dependent {
            background: #999;
            color: white;
        }
        
        .claim-text {
            line-height: 1.6;
        }
        
        .claim-references {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
            color: var(--text-color-secondary);
        }
        
        /* 其他样式 */
        </style>

</head>
<body>
<!-- 加载页面Vanta动画初始化 - 必须尽早执行 -->
<script>
(function() {
    var loadingVanta = null;
    function initLoadingVanta() {
        if (typeof VANTA !== 'undefined' && VANTA.NET && typeof THREE !== 'undefined') {
            var loadingVantaBg = document.getElementById('loading-vanta-bg');
            if (loadingVantaBg && !loadingVanta) {
                var savedTheme = localStorage.getItem('patent-workbench-theme');
                var isDark = savedTheme === 'dark';
                loadingVanta = VANTA.NET({
                    el: "#loading-vanta-bg",
                    mouseControls: true,
                    touchControls: true,
                    gyroControls: false,
                    minHeight: 200.00,
                    minWidth: 200.00,
                    scale: 1.00,
                    scaleMobile: 1.00,
                    color: isDark ? 0x22c55e : 0x4ade80,
                    backgroundColor: isDark ? 0x0f172a : 0xf0fdf4,
                    points: 8.00,
                    maxDistance: 18.00,
                    spacing: 18.00,
                    showDots: true
                });
                console.log('Loading Vanta initialized with theme:', isDark ? 'dark' : 'light');
            }
        }
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initLoadingVanta);
    } else {
        initLoadingVanta();
    }
    setTimeout(initLoadingVanta, 100);
})();
</script>

<!-- 右下角悬浮二维码 -->
<div id="floating-qr" class="floating-qr-container">
    <div class="floating-qr-toggle" id="qr-toggle" title="联系与反馈">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
    </div>
    <div class="floating-qr-panel" id="qr-panel">
        <div class="floating-qr-header">
            <span>联系与反馈</span>
            <button class="floating-qr-close" id="qr-close">&times;</button>
        </div>
        <div class="floating-qr-content">
            <img src="/frontend/images/QRcode.jpg" alt="公众号二维码">
            <p class="floating-qr-title">IP智友</p>
            <p class="floating-qr-desc">扫码关注公众号</p>
            <p class="floating-qr-tip">反馈意见 · 交流问题 · 获取帮助</p>
        </div>
    </div>
</div>

<!-- 加载进度遮罩 -->
<div id="loading-overlay" class="loading-overlay">
    <div id="loading-vanta-bg"></div>
    <div class="loading-content">
        <div class="tech-welcome-container">
            <div class="tech-scan-line"></div>
            <div class="tech-welcome-title">
                <span class="welcome-text-cn" id="welcome-text-cn"></span>
                <span class="tech-cursor">|</span>
            </div>
            <div class="tech-welcome-subtitle">
                <span class="welcome-text-en" id="welcome-text-en"></span>
            </div>
            <div class="tech-loading-bar">
                <div class="tech-loading-progress" id="tech-loading-progress"></div>
            </div>
        </div>
        <div class="loading-spinner-container">
            <div class="loading-spinner"></div>
            <div class="loading-spinner-ring"></div>
            <div class="loading-spinner-ring ring-2"></div>
        </div>
        <div class="loading-text" id="loading-text">正在初始化系统...</div>
        <div id="loading-progress" class="loading-progress">初始化中</div>
    </div>
</div>

<div id="vanta-bg"></div>

<div class="container">
    <!-- Header Component (loaded dynamically) -->
    <div id="header-component"></div>
    
    <div class="main-content">
        <!-- Tab Navigation Component (loaded dynamically) -->
        <div id="tab-navigation-component"></div>

        <!-- 功能一：即时对话 -->

        <!-- 功能一：即时对话 (loaded dynamically) -->
        <div id="instant-chat-component"></div>
        
        <!-- ====================================================================== -->
        
        <!-- Feature 2 (Unified Batch - 文本批量智能分析) (loaded dynamically) -->
        <div id="unified-batch-component"></div>
        
        
        <!-- Feature 3 (Local Patent Library) (loaded dynamically) -->
        <div id="local-patent-lib-component"></div>
        
        
        <!-- Feature 5 (Claims Comparison) (loaded dynamically) -->
        <div id="claims-comparison-component"></div>
        
        
        <!-- Feature 6 (Patent Batch) (loaded dynamically) -->
        <div id="patent-batch-component"></div>
        
        
        <!-- Feature 7 (Claims Processor) (loaded dynamically) -->
        <div id="claims-processor-component"></div>
        
        <!-- Feature 8 (Drawing Marker) (loaded dynamically) -->
        <div id="drawing-marker-component"></div>
        
        <!-- Feature 9 (PDF OCR Reader) (loaded dynamically) -->
        <div id="pdf-ocr-reader-component"></div>
        

<!-- 功能八：专利附图标记功能 -->
<script src="frontend/js/multiImageViewer_v8.js?v=20260201"></script>
<!-- AI说明书处理器 -->
<script src="frontend/js/ai_description/ai_processing_panel.js?v=20260201"></script>
<script src="frontend/js/ai_description/prompt_editor.js?v=20260201"></script>
<!-- 功能八：缓存管理器（必须在重新处理管理器之前加载） -->
<script src="frontend/js/drawingCacheManager.js?v=20260205"></script>
<!-- 功能八：重新处理管理器 -->
<script src="frontend/js/drawingReprocessManager.js?v=20260205"></script>
<!-- 功能八：初始化模块 -->
<script src="js/modules/drawing-marker/drawing-marker-init.js?v=20260207"></script>
<script>
// 专利附图标记功能数据存储
let uploadedDrawings = [];
let currentReferenceMap = {}; // 存储说明书中的标记映射

// Note: Initialization is now handled by js/modules/drawing-marker/drawing-marker-init.js
// which is called by main.js after the component loads

// 尝试恢复缓存的处理结果（改进版：检测输入变化）
function restoreCachedProcessingResult() {
    const specificationInput = document.getElementById('specification_input');
    if (!specificationInput) return;
    
    console.log('[新增] 检查是否有手动保存的缓存标记');
    const hasSavedCache = localStorage.getItem('drawing_cache_saved') === 'true';
    
    if (!hasSavedCache) {
        console.log('[警告] 没有手动保存的缓存，跳过自动恢复');
        return;
    }
    
    // 尝试从localStorage恢复处理结果
    try {
        console.log('开始检查缓存...');
        let latestCache = null;
        let latestCacheKey = null;
        let latestTimestamp = 0;
        
        // 遍历所有localStorage项，查找处理缓存
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('processing_cache_')) {
                try {
                    const cacheData = JSON.parse(localStorage.getItem(key));
                    if (cacheData && cacheData.timestamp) {
                        // 检查缓存是否在24小时内
                        const elapsed = Date.now() - cacheData.timestamp;
                        if (elapsed < 24 * 60 * 60 * 1000) {
                            // 找到最新的缓存
                            if (cacheData.timestamp > latestTimestamp) {
                                latestTimestamp = cacheData.timestamp;
                                latestCache = cacheData;
                                latestCacheKey = key;
                            }
                        } else {
                            // 缓存过期，删除
                            localStorage.removeItem(key);
                            console.log('缓存已过期，已删除:', key);
                        }
                    }
                } catch (parseError) {
                    console.warn('解析缓存失败，删除无效缓存:', key);
                    localStorage.removeItem(key);
                }
            }
        }
        
        // 如果找到最新的缓存
        if (latestCache) {
            console.log('[成功] 发现手动保存的缓存，尝试恢复...', latestCacheKey);
            
            // 恢复上传的图片
            if (latestCache.uploadedDrawings) {
                uploadedDrawings = latestCache.uploadedDrawings.map(d => ({
                    ...d,
                    id: Date.now() + Math.random()
                }));
                console.log('已恢复', uploadedDrawings.length, '张上传的图片');
                
                // 更新上传图片的显示
                if (typeof updateUploadedDrawingsDisplay === 'function') {
                    updateUploadedDrawingsDisplay();
                } else if (typeof updateUploadedDrawingsList === 'function') {
                    updateUploadedDrawingsList();
                }
            }
            
            // 恢复说明书内容
            if (latestCache.specification) {
                specificationInput.value = latestCache.specification;
                console.log('已恢复说明书内容');
            }
            
            // 恢复处理结果
            displayProcessingResult(latestCache.data, latestCache.isAIMode);
            console.log('处理结果已从缓存恢复');
        } else {
            console.log('没有找到有效的缓存');
        }
    } catch (e) {
        console.warn('恢复缓存失败:', e);
    }
}

// 处理图片上传
function handleDrawingUpload(event) {
    const files = event.target.files;
    if (files.length === 0) return;

    // 处理每个上传的文件
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (file.type.startsWith('image/')) {
            processImageFile(file);
        } else {
            alert(`文件 ${file.name} 不是图片格式，请上传图片文件。`);
        }
    }

    // 清空文件输入，允许重复上传同一文件
    event.target.value = '';
}

// 处理图片粘贴
function handleDrawingPaste(event) {
    const items = event.clipboardData.items;
    if (!items) return;

    // 查找粘贴的图片
    for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
            const file = items[i].getAsFile();
            processImageFile(file);
            break;
        }
    }
}

// 处理图片文件
function processImageFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const imageData = {
            id: Date.now() + Math.random(),
            name: file.name,
            type: file.type,
            size: file.size,
            dataUrl: e.target.result,
            rotation: 0
        };
        
        uploadedDrawings.push(imageData);
        updateUploadedDrawingsList();
        
        console.log('[新增] 图片变化时清除缓存标记');
        clearCacheOnInputChange('图片上传');
    };
    reader.readAsDataURL(file);
}

console.log('[新增] 当输入发生变化时清除缓存');
function clearCacheOnInputChange(changeType) {
    // 清除保存标记
    localStorage.removeItem('drawing_cache_saved');
    
    // 清除所有处理缓存
    let removedCount = 0;
    for (let i = localStorage.length - 1; i >= 0; i--) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('processing_cache_') || key.startsWith('cache_'))) {
            localStorage.removeItem(key);
            removedCount++;
        }
    }
    
    console.log(`[刷新] ${changeType}变化，已清除 ${removedCount} 个缓存`);
    
    // 清空标注结果显示
    const annotatedDrawingsContainer = document.getElementById('annotated_drawings_container');
    if (annotatedDrawingsContainer) {
        annotatedDrawingsContainer.innerHTML = '<div style="color: #6c757d; font-size: 14px; text-align: center; padding: 40px; background-color: #f8f9fa; border-radius: 6px; border: 2px dashed #dee2e6;"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-bottom: 10px;"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg><div>处理完成后，标注后的附图将显示在此处</div></div>';
    }
    
    // 清空处理结果
    const processingResult = document.getElementById('processing_result');
    if (processingResult) {
        processingResult.innerHTML = '<div style="color: #6c757d; font-size: 14px; text-align: center; padding: 20px; background-color: #f8f9fa; border-radius: 6px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> 请上传图片和输入说明书，然后点击"开始处理"</div>';
    }
}

// 更新上传图片列表
function updateUploadedDrawingsList() {
    const listContainer = document.getElementById('uploaded_drawings_list');
    if (!listContainer) return;

    if (uploadedDrawings.length === 0) {
        listContainer.innerHTML = '<div style="color: #6c757d; font-size: 12px; text-align: center; padding: 10px;">暂无图片</div>';
        return;
    }

    let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
    uploadedDrawings.forEach((drawing, index) => {
        const sizeKB = (drawing.size / 1024).toFixed(1);
        const rotation = drawing.rotation || 0;
        html += `
            <div style="display: flex; align-items: center; gap: 10px; padding: 8px; background-color: white; border: 1px solid #dee2e6; border-radius: 6px; position: relative;">
                <div style="position: relative; width: 40px; height: 40px; flex-shrink: 0;">
                    <img src="${drawing.dataUrl}" 
                         alt="${drawing.name}" 
                         class="drawing-thumbnail"
                         data-index="${index}"
                         style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; cursor: pointer; transition: transform 0.2s;">
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-size: 12px; color: #495057; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${drawing.name}</div>
                    <div style="font-size: 11px; color: #adb5bd;">${sizeKB} KB | 旋转: ${rotation}°</div>
                </div>
                <div style="display: flex; gap: 5px; flex-shrink: 0;">
                    <button onclick="rotateDrawing(${index}, -90)" style="padding: 4px 8px; font-size: 11px; background-color: #ffc107; color: black; border: none; border-radius: 4px; cursor: pointer;" title="逆时针旋转90°">↶</button>
                    <button onclick="rotateDrawing(${index}, 90)" style="padding: 4px 8px; font-size: 11px; background-color: #ffc107; color: black; border: none; border-radius: 4px; cursor: pointer;" title="顺时针旋转90°">↷</button>
                    <button onclick="previewDrawing(${index})" style="padding: 4px 8px; font-size: 11px; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;" title="预览大图"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M10.5 3.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-8a.5.5 0 0 1 .5-.5h8zM2 4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4z"/><path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/><path d="M11.5 5.5a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1z"/></svg></button>
                    <button onclick="removeDrawing(${index})" style="padding: 4px 8px; font-size: 11px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;" title="删除"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/></svg></button>
                </div>
            </div>
        `;
    });
    html += '</div>';
    
    listContainer.innerHTML = html;
    
    // 添加鼠标悬浮预览功能
    setTimeout(() => {
        document.querySelectorAll('.drawing-thumbnail').forEach(img => {
            img.addEventListener('mouseenter', showImagePreview);
            img.addEventListener('mouseleave', hideImagePreview);
        });
    }, 0);
}

// 删除单个图片
function removeDrawing(index) {
    uploadedDrawings.splice(index, 1);
    updateUploadedDrawingsList();
    
    console.log('[新增] 图片删除时清除缓存');
    clearCacheOnInputChange('图片删除');
}

// 旋转图片（修复版：每次旋转90度，累加角度）
function rotateDrawing(index, degrees) {
    const drawing = uploadedDrawings[index];
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const image = new Image();
    
    image.onload = function() {
        console.log('[修复] 使用累加的旋转角度');
        const currentRotation = drawing.rotation || 0;
        const newRotation = (currentRotation + degrees + 360) % 360; // 确保角度在0-360之间
        
        console.log('[修复] 根据旋转角度决定画布尺寸');
        // 90度和270度时需要交换宽高
        const isVertical = (newRotation === 90 || newRotation === 270);
        canvas.width = isVertical ? image.height : image.width;
        canvas.height = isVertical ? image.width : image.height;
        
        // 清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 旋转并绘制
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate((degrees * Math.PI) / 180); // 修复：只旋转增量角度
        ctx.drawImage(image, -image.width / 2, -image.height / 2);
        ctx.restore();
        
        // 更新图片数据
        uploadedDrawings[index].dataUrl = canvas.toDataURL('image/png');
        uploadedDrawings[index].rotation = newRotation;
        
        console.log(`图片 ${index} 旋转: ${currentRotation}° → ${newRotation}°`);
        
        // 更新列表显示
        updateUploadedDrawingsList();
        
        console.log('[新增] 图片旋转时清除缓存');
        clearCacheOnInputChange('图片旋转');
    };
    
    console.log('[关键] 使用当前已旋转的图片作为基础');
    image.src = drawing.dataUrl;
}

// 预览图片大图
function previewDrawing(index) {
    const drawing = uploadedDrawings[index];
    
    // 创建预览弹窗
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    `;
    
    // 图片信息
    const info = document.createElement('div');
    info.style.cssText = `
        color: white;
        font-size: 16px;
        margin-bottom: 20px;
        text-align: center;
        padding: 10px 20px;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 8px;
    `;
    info.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 5px;">${drawing.name}</div>
        <div style="font-size: 14px; color: #aaa;">
            大小: ${(drawing.size / 1024).toFixed(1)} KB | 
            旋转: ${drawing.rotation || 0}° | 
            点击任意处关闭
        </div>
    `;
    
    // 大图
    const img = document.createElement('img');
    img.src = drawing.dataUrl;
    img.style.cssText = `
        max-width: 90%;
        max-height: 80vh;
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    `;
    
    modal.appendChild(info);
    modal.appendChild(img);
    
    // 点击关闭
    modal.addEventListener('click', () => {
        modal.remove();
    });
    
    // ESC键关闭
    const handleEsc = (e) => {
        if (e.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', handleEsc);
        }
    };
    document.addEventListener('keydown', handleEsc);
    
    document.body.appendChild(modal);
}

// 鼠标悬浮显示预览
let previewTooltip = null;
function showImagePreview(event) {
    const img = event.target;
    const index = parseInt(img.dataset.index);
    const drawing = uploadedDrawings[index];
    
    // 创建预览提示框
    previewTooltip = document.createElement('div');
    previewTooltip.style.cssText = `
        position: fixed;
        z-index: 9999;
        background-color: white;
        border: 2px solid #28a745;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        pointer-events: none;
        max-width: 400px;
    `;
    
    const previewImg = document.createElement('img');
    previewImg.src = drawing.dataUrl;
    previewImg.style.cssText = `
        width: 300px;
        height: auto;
        display: block;
        border-radius: 4px;
    `;
    
    const previewInfo = document.createElement('div');
    previewInfo.style.cssText = `
        margin-top: 8px;
        font-size: 12px;
        color: #666;
        text-align: center;
    `;
    previewInfo.textContent = `${drawing.name} | ${drawing.rotation || 0}°`;
    
    previewTooltip.appendChild(previewImg);
    previewTooltip.appendChild(previewInfo);
    document.body.appendChild(previewTooltip);
    
    // 定位预览框（跟随鼠标）
    const updatePosition = (e) => {
        if (!previewTooltip) return;
        const x = e.clientX + 20;
        const y = e.clientY + 20;
        
        // 防止超出屏幕
        const maxX = window.innerWidth - previewTooltip.offsetWidth - 20;
        const maxY = window.innerHeight - previewTooltip.offsetHeight - 20;
        
        previewTooltip.style.left = Math.min(x, maxX) + 'px';
        previewTooltip.style.top = Math.min(y, maxY) + 'px';
    };
    
    updatePosition(event);
    img.addEventListener('mousemove', updatePosition);
    img.dataset.mousemoveHandler = 'attached';
}

function hideImagePreview(event) {
    if (previewTooltip) {
        previewTooltip.remove();
        previewTooltip = null;
    }
    
    const img = event.target;
    if (img.dataset.mousemoveHandler) {
        delete img.dataset.mousemoveHandler;
    }
}

// 清空所有图片
function clearAllDrawings() {
    uploadedDrawings = [];
    updateUploadedDrawingsList();
    
    // 清空说明书输入
    const specificationInput = document.getElementById('specification_input');
    if (specificationInput) {
        specificationInput.value = '';
    }
    
    // 清空处理结果
    const processingResult = document.getElementById('processing_result');
    if (processingResult) {
        processingResult.innerHTML = '<div style="color: #6c757d; font-size: 14px; text-align: center; padding: 20px; background-color: #f8f9fa; border-radius: 6px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> 请上传图片和输入说明书，然后点击"开始处理"</div>';
    }
    
    // 清空标注后的附图
    const annotatedDrawingsContainer = document.getElementById('annotated_drawings_container');
    if (annotatedDrawingsContainer) {
        annotatedDrawingsContainer.innerHTML = '<div style="color: #6c757d; font-size: 14px; text-align: center; padding: 40px; background-color: #f8f9fa; border-radius: 6px; border: 2px dashed #dee2e6;"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-bottom: 10px;"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg><div>处理完成后，标注后的附图将显示在此处</div></div>';
    }
    
    // 清空处理状态
    const processingStatus = document.getElementById('processing_status');
    if (processingStatus) {
        processingStatus.textContent = '';
    }
}

// 生成缓存键的辅助函数
function generateProcessingCacheKey(drawings, specification) {
    // 基于文件名、数量、顺序和说明书内容生成唯一缓存键
    const drawingInfo = drawings.map(d => {
        return d.name + '_' + d.size + '_' + (d.id || Date.now() + Math.random());
    }).sort().join('|');
    const specHash = specification.length + '_' + (specification.substring(0, 200) || 'empty') + '_' + Math.random().toString(36).substr(2, 9);
    const timestamp = Date.now();
    
    // 安全生成缓存键，处理非ASCII字符
    try {
        // 先编码为UTF-8，再进行base64编码
        const input = drawingInfo + '_' + specHash + '_' + timestamp;
        const encoded = btoa(unescape(encodeURIComponent(input)));
        return 'cache_' + encoded.substring(0, 100);
    } catch (error) {
        // 如果编码失败，使用替代方案
        console.warn('缓存键生成失败，使用替代方案:', error);
        // 使用简单的哈希方案
        let hash = 0;
        const input = drawingInfo + '_' + specHash + '_' + timestamp;
        for (let i = 0; i < input.length; i++) {
            const char = input.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return 'cache_' + Math.abs(hash).toString(36) + '_' + timestamp.toString(36).substr(0, 8);
    }
}

// 更新进度显示的辅助函数
function updateProgressStatus(stage, message) {
    const processingStatus = document.getElementById('processing_status');
    if (!processingStatus) return;
    
    const stageColors = {
        'ocr': '#17a2b8',
        'extract': '#ffc107', 
        'ai': '#28a745',
        'complete': '#28a745',
        'error': '#dc3545'
    };
    
    const color = stageColors[stage] || '#28a745';
    
    processingStatus.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
            <div class="spinner" style="width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid ${color}; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <span id="progress_text" style="color: ${color};">${message}</span>
        </div>
        <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;
}

// 开始处理 - 分阶段处理版本
async function startProcessing() {
    // 表单验证
    if (uploadedDrawings.length === 0) {
        alert('请先上传或粘贴专利附图。');
        return;
    }
    
    const specificationInput = document.getElementById('specification_input');
    if (!specificationInput || specificationInput.value.trim() === '') {
        alert('请输入说明书内容。');
        return;
    }
    
    console.log('开始分阶段处理...');
    
    const aiConfig = window.aiProcessingPanel ? window.aiProcessingPanel.getConfig() : { aiMode: false };
    
    if (aiConfig.aiMode && !aiConfig.model) {
        alert('请选择AI模型。');
        return;
    }
    
    const startBtn = document.getElementById('start_processing_btn');
    if (startBtn) {
        startBtn.disabled = true;
        startBtn.style.opacity = '0.6';
        startBtn.style.cursor = 'not-allowed';
    }
    
    const ocrModeSelect = document.getElementById('ocr_mode_select');
    const ocrMode = ocrModeSelect ? ocrModeSelect.value : 'rapidocr';
    
    const paddleTokenInput = document.getElementById('paddle_token_input');
    const paddleToken = paddleTokenInput ? paddleTokenInput.value.trim() : '';
    
    console.log('[DEBUG] OCR Mode:', ocrMode);
    console.log('[DEBUG] Paddle Token Input Element:', paddleTokenInput);
    console.log('[DEBUG] Paddle Token Value:', paddleToken ? '(已输入)' : '(空)');
    
    const apiKey = appState?.apiKey || localStorage.getItem('zhipuai_api_key') || '';
    
    const headers = {
        'Content-Type': 'application/json'
    };
    
    if (aiConfig.aiMode || ocrMode === 'glm_ocr') {
        if (!apiKey) {
            updateProgressStatus('error', '[错误] AI模式需要API Key');
            alert('AI模式需要配置API Key。请点击右上角设置并保存您的智谱AI API Key。');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
            }
            return;
        }
        headers['Authorization'] = `Bearer ${apiKey}`;
    }
    
    if (ocrMode === 'paddle_ocr' && !paddleToken) {
        updateProgressStatus('error', '[错误] PP-OCRv5模式需要Token');
        alert('PP-OCRv5模式需要输入百度AI Studio Token。');
        if (startBtn) {
            startBtn.disabled = false;
            startBtn.style.opacity = '1';
            startBtn.style.cursor = 'pointer';
        }
        return;
    }
    
    const drawingsData = uploadedDrawings.map(drawing => {
        const base64Data = drawing.dataUrl.split(',')[1];
        return {
            name: drawing.name,
            type: drawing.type,
            size: drawing.size,
            data: base64Data
        };
    });
    
    const specification = specificationInput.value.trim();
    
    try {
        // 阶段1: OCR识别
        updateProgressStatus('ocr', '[OCR] 正在识别图片中的序号...');
        
        const ocrStartTime = Date.now();
        const ocrResponse = await fetchWithTimeout('/api/drawing-marker/process-staged', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify({
                drawings: drawingsData,
                specification: specification,
                ocr_mode: ocrMode,
                paddle_token: paddleToken,
                stage: 'ocr'
            })
        }, 30000);
        
        const ocrResult = await ocrResponse.json();
        
        if (!ocrResult.success) {
            throw new Error(ocrResult.error || 'OCR识别失败');
        }
        
        const ocrMarkers = ocrResult.data.ocr_markers;
        const ocrTime = ((Date.now() - ocrStartTime) / 1000).toFixed(1);
        console.log(`OCR识别完成: ${ocrMarkers.length} 个序号, 耗时 ${ocrTime}秒`);
        console.log('[OCR阶段] ocr_markers:', ocrMarkers);
        console.log('[OCR阶段] drawings:', ocrResult.data.drawings);
        console.log('[OCR阶段] drawings[0]示例:', ocrResult.data.drawings?.[0]);
        
        if (ocrMarkers.length === 0) {
            updateProgressStatus('error', '[错误] 未识别到任何序号，请检查图片');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
            }
            return;
        }
        
        // 阶段2: 提取相关文本
        updateProgressStatus('extract', `[提取] 已识别 ${ocrMarkers.length} 个序号，正在提取说明书相关内容...`);
        
        const extractStartTime = Date.now();
        const extractResponse = await fetchWithTimeout('/api/drawing-marker/process-staged', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify({
                drawings: drawingsData,
                specification: specification,
                ocr_mode: ocrMode,
                ocr_results: ocrMarkers,
                stage: 'extract'
            })
        }, 10000);
        
        const extractResult = await extractResponse.json();
        
        if (!extractResult.success) {
            throw new Error(extractResult.error || '文本提取失败');
        }
        
        const extractTime = ((Date.now() - extractStartTime) / 1000).toFixed(1);
        const extractInfo = extractResult.data;
        console.log(`文本提取完成: ${extractInfo.original_length} -> ${extractInfo.extracted_length} 字符, 耗时 ${extractTime}秒`);
        
        // 阶段3: AI处理
        if (aiConfig.aiMode) {
            updateProgressStatus('ai', `[AI] 已提取 ${extractInfo.segment_count} 个相关段落，正在AI智能匹配...`);
        } else {
            updateProgressStatus('ai', `[规则] 已提取 ${extractInfo.segment_count} 个相关段落，正在规则匹配...`);
        }
        
        const aiStartTime = Date.now();
        const aiResponse = await fetchWithTimeout('/api/drawing-marker/process-staged', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify({
                drawings: drawingsData,
                specification: specification,
                ai_mode: aiConfig.aiMode,
                model_name: aiConfig.model,
                custom_prompt: aiConfig.prompt,
                ocr_mode: ocrMode,
                ocr_results: ocrMarkers,
                ocr_drawings: ocrResult.data.drawings,
                stage: 'ai'
            })
        }, 120000);
        
        const aiResult = await aiResponse.json();
        
        console.log('[AI阶段] 返回结果:', JSON.stringify(aiResult, null, 2));
        
        if (!aiResult.success) {
            throw new Error(aiResult.error || 'AI处理失败');
        }
        
        console.log('[AI阶段] drawings数量:', aiResult.data.drawings?.length);
        console.log('[AI阶段] matched_count:', aiResult.data.matched_count);
        console.log('[AI阶段] ocr_detected_count:', aiResult.data.ocr_detected_count);
        console.log('[AI阶段] reference_map:', aiResult.data.reference_map);
        
        const aiTime = ((Date.now() - aiStartTime) / 1000).toFixed(1);
        const totalTime = ((Date.now() - ocrStartTime) / 1000).toFixed(1);
        console.log(`AI处理完成，耗时 ${aiTime}秒，总耗时 ${totalTime}秒`);
        
        // 显示结果
        updateProgressStatus('complete', `[完成] 处理完成！OCR: ${ocrTime}s | 提取: ${extractTime}s | ${aiConfig.aiMode ? 'AI' : '规则'}: ${aiTime}s`);
        
        displayProcessingResult(aiResult.data, aiConfig.aiMode);
        
    } catch (error) {
        console.error('处理失败:', error);
        
        let errorMessage = '处理失败';
        if (error.name === 'TimeoutError') {
            errorMessage = '⏱️ 处理超时，请重试或缩短说明书长度';
        } else if (error.message) {
            errorMessage = `[错误] ${error.message}`;
        }
        
        updateProgressStatus('error', errorMessage);
        
        const processingResult = document.getElementById('processing_result');
        if (processingResult) {
            processingResult.innerHTML = `
                <div style="padding: 15px; background-color: rgba(220, 53, 69, 0.1); border-radius: 8px; border: 1px solid rgba(220, 53, 69, 0.3);">
                    <h4 style="color: var(--error-color); margin-bottom: 10px;">[错误] 处理失败</h4>
                    <p>${error.message || '未知错误'}</p>
                </div>
            `;
        }
    } finally {
        if (startBtn) {
            startBtn.disabled = false;
            startBtn.style.opacity = '1';
            startBtn.style.cursor = 'pointer';
        }
    }
}

// 带超时的fetch封装
async function fetchWithTimeout(url, options, timeout = 30000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            const timeoutError = new Error('请求超时');
            timeoutError.name = 'TimeoutError';
            throw timeoutError;
        }
        throw error;
    }
}

// 🆕 智能重新处理OCR（检测图片变化，自动选择处理模式）
function reprocessOCR() {
    // 表单验证
    if (uploadedDrawings.length === 0) {
        alert('请先上传或粘贴专利附图。');
        return;
    }
    
    const specificationInput = document.getElementById('specification_input');
    if (!specificationInput || specificationInput.value.trim() === '') {
        alert('请输入说明书内容。');
        return;
    }
    
    console.log('[智能检测] 检查图片是否有旋转或变化');
    const hasRotation = uploadedDrawings.some(d => d.rotation && d.rotation !== 0);
    const hasCache = window.reprocessManager && window.reprocessManager.currentState.hasOCRCache;
    
    let confirmMessage = '';
    if (hasRotation && hasCache) {
        confirmMessage = `检测到图片已旋转，将清除缓存并重新识别OCR。\n\n旋转的图片：${uploadedDrawings.filter(d => d.rotation).length} 张\n\n是否继续？`;
    } else if (hasCache) {
        confirmMessage = `检测到已有OCR缓存，将清除缓存并重新识别。\n\n是否继续？`;
    }
    
    if (confirmMessage && !confirm(confirmMessage)) {
        return;
    }
    
    // 清除缓存，强制重新识别OCR
    console.log('[刷新] 智能重新识别OCR：清除缓存，使用当前图片状态（包括旋转）');
    clearCacheOnInputChange('智能重新识别OCR');
    
    // 获取AI处理配置
    const aiConfig = window.aiProcessingPanel ? window.aiProcessingPanel.getConfig() : { aiMode: false };
    
    if (aiConfig.aiMode && !aiConfig.model) {
        alert('请选择AI模型。');
        return;
    }
    
    // 禁用所有处理按钮
    const reprocessOcrBtn = document.getElementById('reprocess_ocr_btn');
    const reprocessSpecBtn = document.getElementById('reprocess_spec_btn');
    const startBtn = document.getElementById('start_processing_btn');
    
    [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
        if (btn) {
            btn.disabled = true;
            btn.style.opacity = '0.6';
            btn.style.cursor = 'not-allowed';
        }
    });
    
    // 显示进度反馈
    const processingStatus = document.getElementById('processing_status');
    if (processingStatus) {
        processingStatus.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <div class="spinner" style="width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid #2196F3; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <span style="color: #2196F3;">正在重新识别OCR${hasRotation ? '（含旋转）' : ''}...</span>
            </div>
        `;
    }
    
    // 准备数据
    const ocrModeSelect = document.getElementById('ocr_mode_select');
    const ocrMode = ocrModeSelect ? ocrModeSelect.value : 'rapidocr';
    
    const paddleTokenInput = document.getElementById('paddle_token_input');
    const paddleToken = paddleTokenInput ? paddleTokenInput.value.trim() : '';
    
    console.log('[DEBUG reprocessOCR] OCR Mode:', ocrMode);
    console.log('[DEBUG reprocessOCR] Paddle Token Input Element:', paddleTokenInput);
    console.log('[DEBUG reprocessOCR] Paddle Token Value:', paddleToken ? '(已输入)' : '(空)');
    
    const processingData = {
        drawings: uploadedDrawings.map(drawing => {
            const base64Data = drawing.dataUrl.split(',')[1];
            return {
                name: drawing.name,
                type: drawing.type,
                size: drawing.size,
                data: base64Data,
                rotation: drawing.rotation || 0
            };
        }),
        specification: specificationInput.value.trim(),
        ai_mode: aiConfig.aiMode,
        model_name: aiConfig.model,
        custom_prompt: aiConfig.prompt,
        ocr_mode: ocrMode,
        paddle_token: paddleToken,
        force_refresh: true
    };
    
    console.log(`[刷新] 智能重新识别OCR：${uploadedDrawings.length} 张图片`);
    uploadedDrawings.forEach((d, i) => {
        if (d.rotation) {
            console.log(`  图片 ${i}: ${d.name} - 旋转 ${d.rotation}°`);
        }
    });
    
    const timeoutMs = aiConfig.aiMode ? 60000 : 30000;
    const timeoutId = setTimeout(() => {
        if (processingStatus) {
            processingStatus.innerHTML = `
                <div style="color: #856404; background-color: #fff3cd; padding: 10px; border-radius: 4px; border: 1px solid #ffeaa7;">
                    [警告] 处理超时,请重试
                </div>
            `;
        }
        [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
            if (btn) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        });
    }, timeoutMs);
    
    const apiKey = appState?.apiKey || localStorage.getItem('zhipuai_api_key') || '';
    const headers = { 'Content-Type': 'application/json' };
    
    if (aiConfig.aiMode) {
        if (!apiKey) {
            alert('AI模式需要配置API Key。');
            [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
                if (btn) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                }
            });
            return;
        }
        headers['Authorization'] = `Bearer ${apiKey}`;
    }
    
    if (ocrMode === 'paddle_ocr' && !paddleToken) {
        alert('PP-OCRv5模式需要配置PaddleOCR Token。');
        [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
            if (btn) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        });
        return;
    }
    
    if (ocrMode === 'paddle_ocr') {
        headers['X-Paddle-Token'] = paddleToken;
    }
    
    fetch('/api/drawing-marker/process', {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(processingData)
    })
    .then(response => {
        clearTimeout(timeoutId);
        return response.json();
    })
    .then(data => {
        if (data.success && data.data) {
            displayProcessingResult(data.data, aiConfig.aiMode);
            if (processingStatus) {
                processingStatus.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><polyline points="20 6 9 17 4 12"></polyline></svg> OCR识别完成';
                processingStatus.style.color = '#2196F3';
            }
        } else {
            if (processingStatus) {
                processingStatus.innerHTML = `
                    <div style="color: #721c24; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                        [错误] OCR识别失败
                    </div>
                `;
            }
        }
    })
    .catch(error => {
        clearTimeout(timeoutId);
        console.error('OCR识别失败:', error);
        if (processingStatus) {
            processingStatus.innerHTML = `
                <div style="color: #721c24; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                    [错误] 网络错误
                </div>
            `;
        }
    })
    .finally(() => {
        [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
            if (btn) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        });
    });
}

// 🆕 智能重新匹配说明书（检测说明书变化，使用缓存OCR）
function reprocessSpecification() {
    // 表单验证
    const specificationInput = document.getElementById('specification_input');
    if (!specificationInput || specificationInput.value.trim() === '') {
        alert('请输入说明书内容。');
        return;
    }
    
    // 检查是否有缓存的OCR结果
    let hasCachedOCR = false;
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('processing_cache_')) {
            try {
                const cached = JSON.parse(localStorage.getItem(key));
                if (cached && cached.data && cached.data.ocr_detected_count > 0) {
                    hasCachedOCR = true;
                    break;
                }
            } catch (e) {
                // 忽略解析错误
            }
        }
    }
    
    if (!hasCachedOCR) {
        alert('没有找到缓存的OCR识别结果。请先点击"识别OCR"或"开始处理"按钮。');
        return;
    }
    
    console.log('[刷新] 重新匹配说明书：使用缓存的OCR结果');
    
    // 禁用所有处理按钮
    const reprocessOcrBtn = document.getElementById('reprocess_ocr_btn');
    const reprocessSpecBtn = document.getElementById('reprocess_spec_btn');
    const startBtn = document.getElementById('start_processing_btn');
    
    [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
        if (btn) {
            btn.disabled = true;
            btn.style.opacity = '0.6';
            btn.style.cursor = 'not-allowed';
        }
    });
    
    // 显示进度反馈
    const processingStatus = document.getElementById('processing_status');
    if (processingStatus) {
        processingStatus.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <div class="spinner" style="width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid #9C27B0; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <span style="color: #9C27B0;">正在重新匹配说明书...</span>
            </div>
        `;
    }
    
    // 使用 DrawingReprocessManager 重新匹配说明书
    if (window.reprocessManager) {
        const newSpecification = specificationInput.value.trim();
        
        window.reprocessManager.reprocessSpecification(newSpecification)
            .then(result => {
                if (result) {
                    displayProcessingResult(result, false);
                    if (processingStatus) {
                        processingStatus.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><polyline points="20 6 9 17 4 12"></polyline></svg> 说明书匹配完成';
                        processingStatus.style.color = '#9C27B0';
                    }
                    console.log('[成功] 说明书重新匹配完成');
                } else {
                    if (processingStatus) {
                        processingStatus.innerHTML = `
                            <div style="color: #721c24; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                                [错误] 说明书匹配失败
                            </div>
                        `;
                    }
                }
            })
            .catch(error => {
                console.error('说明书匹配失败:', error);
                if (processingStatus) {
                    processingStatus.innerHTML = `
                        <div style="color: #721c24; background-color: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                            [错误] 处理失败: ${error.message}
                        </div>
                    `;
                }
            })
            .finally(() => {
                [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
                    if (btn) {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    }
                });
            });
    } else {
        alert('重新处理管理器未初始化，请刷新页面重试。');
        [reprocessOcrBtn, reprocessSpecBtn, startBtn].forEach(btn => {
            if (btn) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        });
    }
}

// 显示处理结果 - 使用真实API返回的数据
function displayProcessingResult(data, isAIMode = false) {
    // 保存reference_map供交互式标注使用
    currentReferenceMap = data.reference_map || {};
    
    // 缓存处理结果，以便页面刷新后仍然可用
    console.log('[修改] 添加手动保存标记');
    const specificationInput = document.getElementById('specification_input');
    if (specificationInput && uploadedDrawings.length > 0) {
        const specificationText = specificationInput.value.trim();
        const cacheKey = generateProcessingCacheKey(uploadedDrawings, specificationText);
        const cacheData = {
            timestamp: Date.now(),
            data: data,
            isAIMode: isAIMode,
            specification: specificationText,
            uploadedDrawings: uploadedDrawings.map(d => ({
                name: d.name,
                type: d.type,
                size: d.size,
                dataUrl: d.dataUrl,
                rotation: d.rotation || 0
            }))
        };
        
        try {
            // 使用统一的缓存键格式
            const finalCacheKey = 'processing_cache_' + cacheKey;
            localStorage.setItem(finalCacheKey, JSON.stringify(cacheData));
            
            console.log('[新增] 设置保存标记（表示这是处理后的结果，可以恢复）');
            localStorage.setItem('drawing_cache_saved', 'true');
            
            console.log('[成功] 处理结果已缓存（可恢复），缓存键:', finalCacheKey);
        } catch (e) {
            console.warn('缓存失败:', e);
        }
    }
    
    // 更新处理状态
    const processingStatus = document.getElementById('processing_status');
    if (processingStatus) {
        processingStatus.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><polyline points="20 6 9 17 4 12"></polyline></svg> 处理完成';
        processingStatus.style.color = '#28a745';
    }
    
    // 更新处理结果统计
    const processingResult = document.getElementById('processing_result');
    if (processingResult) {
        const hasResults = data.total_numbers > 0;
        const statusColor = hasResults ? '#d4edda' : '#fff3cd';
        const borderColor = hasResults ? '#c3e6cb' : '#ffeaa7';
        const textColor = hasResults ? '#155724' : '#856404';
        const icon = hasResults ? 
            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><polyline points="20 6 9 17 4 12"></polyline></svg>' : 
            '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>';
        
        let html = `
            <div style="padding: 15px; background-color: ${statusColor}; border-radius: 6px; border: 1px solid ${borderColor}; color: ${textColor};">
                <h4 style="margin: 0 0 10px 0; font-size: 16px;">${icon} ${data.message || '处理完成'}</h4>
        `;
        
        // 如果是AI模式,显示AI处理信息
        if (isAIMode && data.language) {
            html += `
                <div style="margin-bottom: 10px; padding: 10px; background-color: rgba(13, 110, 253, 0.1); border-radius: 4px; border: 1px solid rgba(13, 110, 253, 0.2);">
                    <div style="font-size: 13px; color: #0d6efd; margin-bottom: 5px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        <strong>AI处理信息</strong>
                    </div>
                    <div style="font-size: 12px; color: #495057;">
                        <div>检测语言: <strong>${data.language}</strong></div>
            `;
            
            if (data.translated_text) {
                html += `<div style="margin-top: 5px;">已翻译为中文</div>`;
            }
            
            if (data.processing_time) {
                html += `<div style="margin-top: 5px;">处理时间: <strong>${data.processing_time.toFixed(2)}秒</strong></div>`;
            }
            
            if (data.warning) {
                html += `<div style="margin-top: 5px; color: #856404;">[警告] ${data.warning}</div>`;
            }
            
            html += `
                    </div>
                </div>
            `;
        }
        
        html += `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                    <div style="text-align: center; padding: 10px; background-color: white; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #2196F3;">${data.ocr_detected_count || data.total_numbers}</div>
                        <div style="font-size: 12px; color: #6c757d;">OCR识别</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background-color: white; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #28a745;">${data.matched_count || data.total_numbers}</div>
                        <div style="font-size: 12px; color: #6c757d;">说明书匹配</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background-color: white; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #ffc107;">${Math.round(data.avg_confidence || 0)}%</div>
                        <div style="font-size: 12px; color: #6c757d;">平均置信度</div>
                    </div>
                </div>
        `;
        
        // 显示建议
        if (data.suggestions && data.suggestions.length > 0) {
            html += `<div style="margin-top: 10px; padding: 10px; background-color: rgba(40, 167, 69, 0.1); border-radius: 4px; font-size: 13px;">`;
            html += `<strong><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg> 建议:</strong><ul style="margin: 5px 0; padding-left: 20px;">`;
            data.suggestions.forEach(suggestion => {
                html += `<li>${suggestion}</li>`;
            });
            html += `</ul></div>`;
        }
        
        html += `</div>`;
        processingResult.innerHTML = html;
    }
    
    // 更新标注后的附图 - 使用 v8.0 多图查看器
    const annotatedDrawingsContainer = document.getElementById('annotated_drawings_container');
    if (annotatedDrawingsContainer) {
        console.log('[优化] 检查是否有OCR识别结果（而不仅仅是匹配结果）');
        const hasOcrResults = data.ocr_detected_count > 0 || data.total_numbers > 0;
        const hasMatchedResults = data.matched_count > 0 || data.total_numbers > 0;
        
        console.log('[优化] 即使没有匹配结果，只要有OCR识别结果，也允许打开调试面板');
        if (!hasOcrResults) {
            // 完全没有OCR识别结果
            annotatedDrawingsContainer.innerHTML = `
                <div style="color: #856404; background-color: #fff3cd; padding: 20px; border-radius: 6px; border: 1px solid #ffeaa7; text-align: center;">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-bottom: 10px;">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    <div style="font-size: 16px; font-weight: bold; margin-bottom: 15px;">[错误] OCR未识别到任何标记</div>
                    <div style="font-size: 14px; color: #856404; line-height: 1.8;">
                        <strong>可能的原因：</strong><br>
                        • 图片清晰度不足，标记模糊不清<br>
                        • 图片中没有数字或字母标记<br>
                        • 标记字体过小或过于艺术化<br>
                        • 图片对比度太低，标记难以识别<br><br>
                        <strong>建议：</strong><br>
                        • 使用更高分辨率的图片<br>
                        • 确认图片包含清晰的数字序号（如10、20、30）<br>
                        • 尝试调整图片亮度和对比度
                    </div>
                </div>
            `;
            return;
        }
        
        // 准备多图查看器数据
        const viewerImages = [];
        data.drawings.forEach((processedDrawing, index) => {
            const originalDrawing = uploadedDrawings.find(d => d.name === processedDrawing.name);
            if (originalDrawing) {
                viewerImages.push({
                    url: originalDrawing.dataUrl,
                    title: processedDrawing.name,
                    detectedNumbers: processedDrawing.detected_numbers || [],
                    referenceMap: currentReferenceMap
                });
            }
        });
        
        // 保存到全局供后续使用
        window.currentViewerImages = viewerImages;

        // 创建分析任务
        const taskName = `分析任务_${new Date().toLocaleString()}`;
        window.currentTaskId = MultiImageViewerV8.TaskManager.createTask(taskName, viewerImages);
        console.log('Created task:', window.currentTaskId);
        
        console.log('[优化] 根据匹配情况显示不同的提示');
        let buttonText = `打开多图查看器 (${viewerImages.length}张图片)`;
        let buttonStyle = 'padding: 15px 30px; font-size: 16px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4); transition: transform 0.2s;';
        let tipHtml = '';
        
        if (!hasMatchedResults && hasOcrResults) {
            // 有OCR识别但没有匹配
            buttonText = `[查看] 查看OCR识别结果 (${viewerImages.length}张图片)`;
            buttonStyle = 'padding: 15px 30px; font-size: 16px; background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%); color: white; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(255, 165, 0, 0.4); transition: transform 0.2s;';
            tipHtml = `
                <div style="margin-bottom: 15px; padding: 12px; background-color: #fff3e0; border-left: 4px solid #FFA500; border-radius: 4px; color: #856404;">
                    <strong>[提示]</strong> OCR识别到 ${data.ocr_detected_count} 个标记，但说明书未匹配。<br>
                    点击下方按钮可查看OCR识别的所有标记（橙色显示），并使用调试面板了解详情。
                </div>
            `;
        }
        
        // 显示图片缩略图和打开按钮
        let html = tipHtml + `
            <div style="text-align: center; margin-bottom: 20px;">
                <button onclick="openMultiImageViewer()" style="${buttonStyle}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                    ${buttonText}
                </button>
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
        `;
        
        viewerImages.forEach((img, index) => {
            const detectedCount = img.detectedNumbers.length;
            html += `
                <div onclick="openMultiImageViewer(${index})" style="cursor: pointer; border: 1px solid #dee2e6; border-radius: 8px; padding: 10px; background-color: white; transition: transform 0.2s, box-shadow 0.2s;" onmouseenter="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 4px 16px rgba(0,0,0,0.15)';" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                    <div style="width: 100%; height: 150px; background-color: #f8f9fa; border-radius: 4px; display: flex; justify-content: center; align-items: center; overflow: hidden; margin-bottom: 10px;">
                        <img src="${img.url}" alt="${img.title}" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                    </div>
                    <div style="font-size: 13px; font-weight: bold; color: #495057; margin-bottom: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${img.title}</div>
                    <div style="font-size: 12px; color: #28a745;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                        </svg>
                        ${detectedCount} 个标记
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        
        // 🆕 添加重新处理按钮区域
        html += `
            <div id="reprocessSection" style="margin-top: 30px; padding: 20px; background-color: #f8f9fa; border-radius: 12px; border-left: 4px solid #2196F3;">
                <h4 style="color: #2196F3; margin: 0 0 10px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                    </svg>
                    <span>快速重新处理</span>
                </h4>
                <p style="color: #666; font-size: 13px; margin: 0 0 15px 0; line-height: 1.6;">
                    已检测到缓存数据，可以单独更新说明书或图片，无需完整重新处理，大幅提升速度。
                </p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="reprocessSpecBtn" onclick="handleReprocessSpecification()" style="flex: 1; min-width: 200px; padding: 12px 20px; background-color: #2196F3; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; justify-content: center; gap: 8px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                        </svg>
                        <span>重新处理说明书</span>
                    </button>
                    <button id="reprocessDrawingsBtn" onclick="handleReprocessDrawings()" style="flex: 1; min-width: 200px; padding: 12px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; justify-content: center; gap: 8px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <span>重新识别图片标号</span>
                    </button>
                </div>
                <div id="cacheInfoTip" style="margin-top: 12px; padding: 10px; background-color: #e3f2fd; border-radius: 6px; font-size: 12px; color: #1565C0; line-height: 1.6;">
                    <strong>提示：</strong>
                    <span id="cacheInfoText">已缓存 ${data.ocr_detected_count || 0} 个OCR识别结果和 ${Object.keys(data.reference_map || {}).length} 个说明书标记，可快速重新处理。</span>
                </div>
            </div>
        `;
        
        annotatedDrawingsContainer.innerHTML = html;
    }
    
    // 🆕 初始化重新处理管理器状态
    if (window.reprocessManager && uploadedDrawings.length > 0) {
        const specificationInput = document.getElementById('specification_input');
        const specificationText = specificationInput ? specificationInput.value.trim() : '';
        window.reprocessManager.updateState(data, specificationText, uploadedDrawings);
    }
}

// 🆕 重新处理说明书（底部按钮 - 调用顶部智能按钮）
async function handleReprocessSpecification() {
    // 直接调用顶部的智能重新匹配说明书按钮
    const reprocessSpecBtn = document.getElementById('reprocess_spec_btn');
    if (reprocessSpecBtn) {
        reprocessSpecBtn.click();
    } else {
        // 如果顶部按钮不存在，使用原有逻辑
        reprocessSpecification();
    }
}

// 🆕 重新识别图片标号（底部按钮 - 调用顶部智能按钮）
async function handleReprocessDrawings() {
    // 检查是否有图片旋转或变化
    const hasRotation = uploadedDrawings.some(d => d.rotation && d.rotation !== 0);
    
    if (hasRotation) {
        // 如果有旋转，提示用户使用顶部的OCR按钮
        const useTopButton = confirm('检测到图片已旋转。\n\n建议使用顶部的"OCR"按钮重新识别（会使用当前旋转状态）。\n\n是否跳转到顶部按钮？');
        if (useTopButton) {
            const reprocessOcrBtn = document.getElementById('reprocess_ocr_btn');
            if (reprocessOcrBtn) {
                // 滚动到顶部按钮
                reprocessOcrBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // 高亮按钮
                reprocessOcrBtn.style.boxShadow = '0 0 0 3px rgba(33, 150, 243, 0.5)';
                setTimeout(() => {
                    reprocessOcrBtn.style.boxShadow = '';
                }, 2000);
            }
        }
        return;
    }
    
    // 如果没有旋转，直接调用顶部的OCR按钮
    const reprocessOcrBtn = document.getElementById('reprocess_ocr_btn');
    if (reprocessOcrBtn) {
        reprocessOcrBtn.click();
    } else {
        // 如果顶部按钮不存在，使用原有逻辑
        reprocessOCR();
    }
}

// 🆕 显示Toast提示
function showToast(message, type = 'info') {
    // 简单的alert实现，可以后续优化为更美观的toast
    alert(message);
}

// 打开多图查看器
function openMultiImageViewer(startIndex = 0) {
    if (!window.currentViewerImages || window.currentViewerImages.length === 0) {
        alert('没有可查看的图片');
        return;
    }

    const viewer = new MultiImageViewerV8(window.currentViewerImages, {
        fontSize: 22,
        highlightColor: '#FFD700'
    });
    viewer.open(startIndex, window.currentTaskId);
}

// 导出单个附图（从多图查看器中）
function exportDrawing(index) {
    if (!window.currentViewerImages || !window.currentViewerImages[index]) {
        alert('无法导出图片');
        return;
    }
    
    // 创建临时canvas导出
    const img = window.currentViewerImages[index];
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const image = new Image();
    image.onload = function() {
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);
        
        // 创建下载链接
        const link = document.createElement('a');
        link.download = `${img.title || 'annotated_drawing'}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    };
    image.src = img.url;
}

// 旧的静态绘制函数已被交互式系统替代

// Note: initDrawingMarker() is now called by main.js after the component loads

</script>

<!-- 新增：专利附图展示和按需爬取功能 -->
<script>
// 专利附图数据存储
let currentPatentDrawings = [];
let currentDrawingIndex = 0;
let currentPatentNumber = '';

// 初始化专利附图功能
function initPatentDrawings() {
    // 监听专利搜索结果的展示，添加附图预览
    document.addEventListener('DOMContentLoaded', function() {
        // 等待专利搜索结果加载完成后，添加附图预览
        const patentResultsList = document.getElementById('patent_results_list');
        if (patentResultsList) {
            // 添加MutationObserver，监听专利结果列表的变化
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // 为每个专利结果添加附图预览
                        const patentItems = document.querySelectorAll('.patent-result-item');
                        patentItems.forEach(function(item) {
                            if (!item.querySelector('.patent-drawings-preview')) {
                                addDrawingsPreview(item);
                            }
                        });
                    }
                });
            });
            
            observer.observe(patentResultsList, { childList: true, subtree: true });
        }
    });
}

// 为专利结果项添加附图预览
function addDrawingsPreview(patentItem) {
    const patentNumber = patentItem.dataset.patentNumber;
    const patentData = JSON.parse(patentItem.dataset.patentData);
    
    if (patentData.drawings && patentData.drawings.length > 0) {
        // 创建附图预览区域
        const drawingsPreview = document.createElement('div');
        drawingsPreview.className = 'patent-drawings-preview';
        drawingsPreview.style.marginTop = '15px';
        drawingsPreview.style.borderTop = '1px solid var(--border-color)';
        drawingsPreview.style.paddingTop = '15px';
        
        // 添加首张附图预览
        const firstDrawing = patentData.drawings[0];
        drawingsPreview.innerHTML = `
            <div style="display: flex; align-items: center; gap: 15px;">
                <div style="flex: 1;">
                    <h5>附图预览</h5>
                    <img src="${firstDrawing}" style="max-width: 150px; max-height: 100px; border-radius: 4px; cursor: pointer; border: 1px solid var(--border-color);" onclick="showDrawingsModal('${patentNumber}', [])">
                </div>
                <button class="small-button" onclick="viewFullDrawings('${patentNumber}')">查看完整附图</button>
            </div>
        `;
        
        // 将附图预览添加到专利结果项
        patentItem.appendChild(drawingsPreview);
    }
}

// 打开附图弹窗
function showDrawingsModal(patentNumber, drawings = []) {
    currentPatentNumber = patentNumber;
    currentPatentDrawings = drawings;
    currentDrawingIndex = 0;
    
    const modal = document.getElementById('drawings_modal');
    const title = document.getElementById('drawings_modal_title');
    const loading = document.getElementById('drawings_loading');
    const container = document.getElementById('drawings_container');
    
    title.textContent = `专利 ${patentNumber} 附图`;
    modal.style.display = 'block';
    loading.style.display = 'block';
    container.style.display = 'none';
    
    // 如果没有提供附图数据，从服务器获取
    if (drawings.length === 0) {
        fetchFullDrawings(patentNumber);
    } else {
        displayDrawings();
    }
}

// 关闭附图弹窗
function closeDrawingsModal() {
    const modal = document.getElementById('drawings_modal');
    modal.style.display = 'none';
    currentPatentDrawings = [];
    currentDrawingIndex = 0;
    currentPatentNumber = '';
}

// 从服务器获取完整附图
function fetchFullDrawings(patentNumber) {
    const loading = document.getElementById('drawings_loading');
    loading.innerHTML = '正在获取完整附图...';
    
    fetch('/api/patent/drawings', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ patent_number: patentNumber })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.data) {
            currentPatentDrawings = data.data.drawings;
            displayDrawings();
        } else {
            loading.innerHTML = `获取附图失败: ${data.error || '未知错误'}`;
        }
    })
    .catch(error => {
        console.error('获取附图失败:', error);
        loading.innerHTML = '获取附图失败，请重试';
    });
}

// 显示附图
function displayDrawings() {
    const loading = document.getElementById('drawings_loading');
    const container = document.getElementById('drawings_container');
    const drawingsCount = document.getElementById('drawings_count');
    const currentDrawing = document.getElementById('current_drawing');
    const prevBtn = document.getElementById('prev_drawing');
    const nextBtn = document.getElementById('next_drawing');
    
    loading.style.display = 'none';
    container.style.display = 'block';
    
    drawingsCount.textContent = `第 ${currentDrawingIndex + 1} 张 / 共 ${currentPatentDrawings.length} 张`;
    currentDrawing.src = currentPatentDrawings[currentDrawingIndex];
    
    // 更新导航按钮状态
    prevBtn.disabled = currentDrawingIndex === 0;
    nextBtn.disabled = currentDrawingIndex === currentPatentDrawings.length - 1;
}

// 显示上一张附图
function showPrevDrawing() {
    if (currentDrawingIndex > 0) {
        currentDrawingIndex--;
        displayDrawings();
    }
}

// 显示下一张附图
function showNextDrawing() {
    if (currentDrawingIndex < currentPatentDrawings.length - 1) {
        currentDrawingIndex++;
        displayDrawings();
    }
}

// 查看完整附图
function viewFullDrawings(patentNumber) {
    showDrawingsModal(patentNumber);
}

// 初始化专利附图功能
initPatentDrawings();
</script>

    <!-- 专利对话弹窗 -->
    <div id="patent_chat_modal" style="display: none;">
        <div class="patent-chat-modal">
            <div class="modal-header">
                <div class="patent-info">
                    <h4 class="patent-chat-title">专利对话</h4>
                    <p class="patent-chat-subtitle"></p>
                </div>
                <button class="close-btn" id="patent_chat_close_btn">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="chat-config-bar">
                    <div class="config-row">
                        <label>服务商:</label>
                        <select id="patent_chat_provider" class="provider-select"></select>
                    </div>
                    <div class="config-row">
                        <label>模型:</label>
                        <select id="patent_chat_model" class="model-select"></select>
                        <button id="patent_chat_thinking_btn" class="thinking-btn" title="深度思考模式" style="display: none;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                <circle cx="8" cy="8" r="7"></circle>
                                <path d="M8 12v-4M8 6h.01"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="chat-actions">
                    <button id="patent_chat_clear_btn">清空对话</button>
                    <button id="patent_chat_export_btn">导出对话</button>
                </div>
                
                <div id="patent_chat_history" class="chat-history"></div>
                
                <div class="chat-input-area">
                    <textarea id="patent_chat_input" placeholder="请输入您的问题..."></textarea>
                    <div class="input-buttons">
                        <button id="patent_chat_stop_btn" class="small-button stop-btn" style="display: none; background: #e74c3c;">停止</button>
                        <button id="patent_chat_send_btn" class="small-button">发送</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 右侧帮助标签按钮 -->
<div class="help-tab-container">
    <a href="frontend/help.html" target="_blank" class="help-tab" title="打开帮助文档">
        <span class="help-tab-text">帮助</span>
        <span class="help-tab-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
        </span>
    </a>
</div>

<!-- Core modules - must load before main.js -->
    <script src="js/core/component-loader.js"></script>
    <script src="js/core/api.js"></script>
    <script src="js/core/provider.js"></script>
    <script src="js/core/feature-lock.js"></script>
    <script src="js/core/theme-manager.js?v=20260227"></script>
    
    <!-- User Cache Management - 用户数据隔离模块 -->
    <script src="js/core/user-cache-storage.js?v=20260221"></script>
    <script src="js/core/user-cache-manager.js?v=20260221"></script>
    <script src="js/core/user-cache-exporter.js?v=20260221"></script>
    <script src="js/core/user-cache-importer.js?v=20260221"></script>
    <script src="js/core/user-cache-merger.js?v=20260221"></script>
    <script src="js/modules/user-data/user-data-ui.js?v=20260221"></script>
    <script src="js/modules/user-data/user-data-modal.js?v=20260221"></script>
    
    <script src="js/modules/navigation/tab-navigation.js"></script>
    
    <!-- Initialization fix - must load before other modules -->
    <script src="js/init-fix.js"></script>
    
    <!-- DOM element references - must load before other modules -->
    <script src="js/dom.js"></script>
    
    <!-- State management - must load before chat modules -->
    <script src="js/state.js?v=20260207e"></script>
    
    <!-- Chat modules - load in dependency order -->
    <script src="js/modules/chat/chat-file-handler.js"></script>
    <script src="js/modules/chat/chat-conversation.js"></script>
    <script src="js/modules/chat/chat-message.js"></script>
    <script src="js/modules/chat/chat-persona.js"></script>
    <script src="js/modules/chat/chat-search.js"></script>
    <script src="js/modules/chat/chat-export.js"></script>
    <script src="js/modules/chat/chat-core.js"></script>
    
    <!-- Feature 2: Unified Batch (合并了原功能二和功能三) -->
    <script type="module" src="js/modules/unified-batch/config.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/state.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/router.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/input-handler.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/template-manager.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/output-handler.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/engines/async-engine.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/engines/batch-engine.js?v=20260222"></script>
    <script type="module" src="js/modules/unified-batch/index.js?v=20260222"></script>
    <script src="js/modules/init/init-unified-batch.js?v=20260222"></script>
    
    <!-- Feature 4: Local Patent Library -->
    <script src="js/localPatentLib.js?v=20260207"></script>
    <script src="js/modules/init/init-local-patent-lib.js?v=20260207"></script>
    
    <!-- Feature 5: Claims Comparison -->
    <script src="js/claimsComparison.js?v=20260207"></script>
    <script src="js/familyClaimsComparison.js?v=20260223"></script>
    <script src="js/modules/init/init-claims-comparison.js?v=20260207"></script>
    
    <!-- Feature 6: Patent Batch -->
    <script src="js/patentTemplate.js"></script>
    <script src="js/patentChat.js"></script>
    <script src="js/modules/patent-batch/field-selector.js"></script>
    <script src="js/modules/patent-batch/patent-cache.js"></script>
    <script src="js/modules/patent-batch/patent-history.js"></script>
    <script src="js/modules/patent-batch/cache-confirm-modal.js"></script>
    <script src="js/modules/init/init-patent-batch.js"></script>
    
    <!-- Feature 7: Claims Processor - Modular Version -->
    <script type="module" src="js/modules/claims/claims-file-handler.js?v=20260207c"></script>
    <script type="module" src="js/modules/claims/claims-processor.js?v=20260207c"></script>
    <script type="module" src="js/modules/claims/claims-visualization.js?v=20260207c"></script>
    <script type="module" src="js/modules/claims/claims-text-analyzer.js?v=20260207c"></script>
    <script type="module" src="js/modules/claims/claims-patent-search.js?v=20260207c"></script>
    <script type="module" src="js/modules/claims/claims-core.js?v=20260207c"></script>
    
    <!-- Feature 9: PDF OCR Reader -->
    <script src="js/modules/pdf-ocr/pdf-ocr-cache.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-core.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-viewer.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-parser.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-chat.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-selection.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-floating-toolbar.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-floating-chat.js?v=20260221"></script>
    <script src="js/modules/pdf-ocr/pdf-ocr-init.js?v=20260221"></script>
    
    <!-- Other feature scripts -->
    <script src="js/patentDetailNewTab.js"></script>
    <script src="js/aiDisclaimer.js"></script>
    <script src="js/fileParserHandler.js"></script>
    
    <!-- 功能六：关系专利分析标签页模块 -->
    <script src="js/modules/patent-batch/tab-manager.js"></script>
    <script src="js/modules/patent-batch/relation-batch-crawler.js"></script>
    
    <!-- Main module files - extracted from main.js -->
    <script src="js/main/patent-detail-html.js"></script>
    <script src="js/main/patent-export.js"></script>
    
    <!-- Main initialization - must load last -->
    <script src="js/main.js?v=20260215a"></script>
    
    <!-- 延迟加载非关键库 -->
    <script>
    // 资源加载管理器
    window.ResourceLoader = {
        loadedScripts: new Map(),
        loadingPromises: new Map(),
        
        // 延迟加载脚本
        loadScript: function(src, options = {}) {
            // 如果已经在加载中，返回现有的 Promise
            if (this.loadingPromises.has(src)) {
                return this.loadingPromises.get(src);
            }
            
            // 如果已经加载完成，返回 resolved Promise
            if (this.loadedScripts.has(src)) {
                return Promise.resolve();
            }
            
            const promise = new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = options.async !== false;
                script.defer = options.defer === true;
                
                if (options.module) {
                    script.type = 'module';
                }
                
                script.onload = () => {
                    this.loadedScripts.set(src, true);
                    this.loadingPromises.delete(src);
                    console.log(`[成功] 脚本加载完成: ${src}`);
                    resolve();
                };
                script.onerror = (err) => {
                    this.loadingPromises.delete(src);
                    console.warn(`[警告] 脚本加载失败: ${src}`, err);
                    reject(err);
                };
                
                document.head.appendChild(script);
            });
            
            this.loadingPromises.set(src, promise);
            return promise;
        },
        
        // 检查库是否可用
        isLibraryAvailable: function(libName) {
            switch(libName) {
                case 'xlsx': return typeof XLSX !== 'undefined';
                case 'html2canvas': return typeof html2canvas !== 'undefined';
                case 'jspdf': return typeof jspdf !== 'undefined';
                case 'd3': return typeof d3 !== 'undefined';
                case 'marked': return typeof marked !== 'undefined';
                case 'three': return typeof THREE !== 'undefined';
                case 'vanta': return typeof VANTA !== 'undefined';
                default: return false;
            }
        },
        
        // 确保库已加载（如果未加载则自动加载）
        ensureLibrary: async function(libName) {
            if (this.isLibraryAvailable(libName)) {
                return Promise.resolve();
            }
            
            const libUrls = {
                'xlsx': 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js',
                'html2canvas': 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js',
                'jspdf': 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
                'd3': 'https://d3js.org/d3.v7.min.js',
                'marked': 'https://cdn.jsdelivr.net/npm/marked/marked.min.js',
                'three': 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js',
                'vanta': 'https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js'
            };
            
            if (libUrls[libName]) {
                console.log(`[加载] 正在按需加载库: ${libName}`);
                return this.loadScript(libUrls[libName], { async: true });
            }
            
            return Promise.reject(new Error(`未知的库: ${libName}`));
        },
        
        // 延迟加载非首屏库
        loadDeferredLibraries: function() {
            const deferredLibs = [
                { src: 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js', name: 'html2canvas' },
                { src: 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', name: 'jspdf' },
                { src: 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js', name: 'xlsx' },
                { src: 'https://d3js.org/d3.v7.min.js', name: 'd3' },
                { src: 'https://cdn.jsdelivr.net/npm/marked/marked.min.js', name: 'marked' },
            ];
            
            const loadNext = (index) => {
                if (index >= deferredLibs.length) return;
                
                const lib = deferredLibs[index];
                this.loadScript(lib.src, { async: true }).then(() => {
                    setTimeout(() => loadNext(index + 1), 100);
                }).catch(err => {
                    loadNext(index + 1);
                });
            };
            
            if (document.readyState === 'complete') {
                setTimeout(() => loadNext(0), 1000);
            } else {
                window.addEventListener('load', () => {
                    setTimeout(() => loadNext(0), 1000);
                });
            }
        },
        
        // 按需加载背景动画库
        loadBackgroundLibs: async function() {
            try {
                // 检查 Three.js 和 Vanta.js 是否已经加载（头部已同步加载）
                if (typeof THREE !== 'undefined' && typeof VANTA !== 'undefined') {
                    console.log('[成功] Three.js 和 Vanta.js 已在头部加载');
                } else {
                    // 如果没有加载，则加载它们
                    if (typeof THREE === 'undefined') {
                        await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js', { async: false });
                        console.log('[成功] Three.js 加载完成');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    if (typeof VANTA === 'undefined') {
                        await this.loadScript('https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js', { async: false });
                        console.log('[成功] Vanta.js 加载完成');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // 初始化主内容区域的 Vanta.js 背景
                if (typeof VANTA !== 'undefined' && VANTA.NET && typeof THREE !== 'undefined') {
                    var vantaBg = document.getElementById('vanta-bg');
                    if (vantaBg) {
                        var savedTheme = localStorage.getItem('patent-workbench-theme');
                        var isDark = savedTheme === 'dark';
                        VANTA.NET({
                            el: "#vanta-bg",
                            mouseControls: true,
                            touchControls: true,
                            gyroControls: false,
                            minHeight: 200.00,
                            minWidth: 200.00,
                            scale: 1.00,
                            scaleMobile: 1.00,
                            color: isDark ? 0x22c55e : 0x4ade80,
                            backgroundColor: isDark ? 0x0f172a : 0xf0fdf4,
                            points: 8.00,
                            maxDistance: 18.00,
                            spacing: 18.00,
                            showDots: true
                        });
                        console.log('[成功] 主背景 Vanta.js 初始化成功，主题:', isDark ? 'dark' : 'light');
                    }
                } else {
                    console.warn('[警告] Vanta 或 Three.js 未加载成功，跳过背景动画');
                }
            } catch (err) {
                console.warn('[警告] 背景动画加载失败:', err);
            }
        }
    };
    
    // 页面加载完成后执行
    document.addEventListener('DOMContentLoaded', function() {
        // 延迟加载非关键库
        window.ResourceLoader.loadDeferredLibraries();
        
        // 延迟加载背景动画库（低优先级）
        if ('requestIdleCallback' in window) {
            requestIdleCallback(() => {
                window.ResourceLoader.loadBackgroundLibs();
            }, { timeout: 5000 });
        } else {
            setTimeout(() => {
                window.ResourceLoader.loadBackgroundLibs();
            }, 3000);
        }
    });
    </script>
    
    <script>
    (function() {
        const toggle = document.getElementById('qr-toggle');
        const panel = document.getElementById('qr-panel');
        const closeBtn = document.getElementById('qr-close');
        
        if (toggle && panel && closeBtn) {
            toggle.addEventListener('click', function() {
                panel.classList.toggle('show');
            });
            
            closeBtn.addEventListener('click', function() {
                panel.classList.remove('show');
            });
            
            document.addEventListener('click', function(e) {
                const container = document.getElementById('floating-qr');
                if (container && !container.contains(e.target)) {
                    panel.classList.remove('show');
                }
            });
        }
    })();
    </script>
</body>
</html>
