<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专利权利要求可视化测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            background: #007bff;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .visualization-container {
            width: 100%;
            height: 600px;
            position: relative;
        }
        
        .node {
            cursor: pointer;
            stroke-width: 2px;
        }
        
        .node.independent {
            fill: #4CAF50;
            stroke: #2E7D32;
        }
        
        .node.dependent {
            fill: #2196F3;
            stroke: #1565C0;
        }
        
        .node:hover {
            stroke-width: 3px;
            filter: brightness(1.1);
        }
        
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
        }
        
        .node-label {
            font-family: Arial, sans-serif;
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            fill: white;
            font-weight: bold;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .btn:hover {
            background: #f0f0f0;
        }
        
        .btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>专利权利要求可视化测试</h1>
            <p>演示专利: CN202310123456A - 一种智能手机及其控制方法</p>
        </div>
        
        <div class="controls">
            <label>可视化样式:</label>
            <button class="btn active" onclick="switchStyle('tree')">树状图</button>
            <button class="btn" onclick="switchStyle('network')">网络图</button>
            <button class="btn" onclick="switchStyle('radial')">径向图</button>
            
            <div style="margin-left: auto;">
                <button class="btn" onclick="renderer.zoomIn()">放大</button>
                <button class="btn" onclick="renderer.zoomOut()">缩小</button>
                <button class="btn" onclick="renderer.zoomReset()">重置</button>
                <button class="btn" onclick="renderer.centerView()">居中</button>
            </div>
        </div>
        
        <div class="visualization-container" id="visualizationContainer">
            <svg id="visualizationSvg"></svg>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // 测试数据
        const testData = {
            patent_number: "CN202310123456A",
            nodes: [
                {
                    id: "claim_1",
                    claim_number: 1,
                    claim_text: "一种智能手机，包括：处理器，用于执行应用程序；存储器，与所述处理器连接，用于存储数据；显示屏，与所述处理器连接，用于显示信息。",
                    claim_type: "independent",
                    level: 0,
                    dependencies: [],
                    children: ["claim_2", "claim_3", "claim_4"]
                },
                {
                    id: "claim_2",
                    claim_number: 2,
                    claim_text: "根据权利要求1所述的智能手机，其特征在于，还包括摄像头，与所述处理器连接，用于拍摄照片和视频。",
                    claim_type: "dependent",
                    level: 1,
                    dependencies: [1],
                    children: ["claim_5"]
                },
                {
                    id: "claim_3",
                    claim_number: 3,
                    claim_text: "根据权利要求1所述的智能手机，其特征在于，还包括传感器模块，用于检测设备的运动状态。",
                    claim_type: "dependent",
                    level: 1,
                    dependencies: [1],
                    children: ["claim_6"]
                },
                {
                    id: "claim_4",
                    claim_number: 4,
                    claim_text: "根据权利要求1所述的智能手机，其特征在于，所述显示屏为触摸屏，支持多点触控操作。",
                    claim_type: "dependent",
                    level: 1,
                    dependencies: [1],
                    children: []
                },
                {
                    id: "claim_5",
                    claim_number: 5,
                    claim_text: "根据权利要求2所述的智能手机，其特征在于，所述摄像头包括前置摄像头和后置摄像头。",
                    claim_type: "dependent",
                    level: 2,
                    dependencies: [2],
                    children: []
                },
                {
                    id: "claim_6",
                    claim_number: 6,
                    claim_text: "根据权利要求3所述的智能手机，其特征在于，所述传感器模块包括加速度传感器和陀螺仪传感器。",
                    claim_type: "dependent",
                    level: 2,
                    dependencies: [3],
                    children: []
                },
                {
                    id: "claim_7",
                    claim_number: 7,
                    claim_text: "一种移动通信设备，包括：无线通信模块，用于与基站进行通信；天线，与所述无线通信模块连接。",
                    claim_type: "independent",
                    level: 0,
                    dependencies: [],
                    children: ["claim_8"]
                },
                {
                    id: "claim_8",
                    claim_number: 8,
                    claim_text: "根据权利要求7所述的移动通信设备，其特征在于，还包括电池管理系统，用于管理设备的电源。",
                    claim_type: "dependent",
                    level: 1,
                    dependencies: [7],
                    children: []
                }
            ],
            links: [
                { source: "claim_1", target: "claim_2", type: "dependency", strength: 1.0 },
                { source: "claim_1", target: "claim_3", type: "dependency", strength: 1.0 },
                { source: "claim_1", target: "claim_4", type: "dependency", strength: 1.0 },
                { source: "claim_2", target: "claim_5", type: "dependency", strength: 1.0 },
                { source: "claim_3", target: "claim_6", type: "dependency", strength: 1.0 },
                { source: "claim_7", target: "claim_8", type: "dependency", strength: 1.0 }
            ],
            root_nodes: ["claim_1", "claim_7"]
        };

        // D3TreeRenderer类 - 基础D3.js渲染器
        class D3TreeRenderer {
            constructor(containerId) {
                this.container = d3.select(`#${containerId}`);
                this.svg = this.container.select('#visualizationSvg');
                this.tooltip = d3.select('#tooltip');
                
                // 获取容器尺寸
                this.updateDimensions();
                
                // 创建主要的SVG组
                this.mainGroup = this.svg.append('g').attr('class', 'main-group');
                
                // 设置缩放行为
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on('zoom', (event) => {
                        this.mainGroup.attr('transform', event.transform);
                    });
                
                this.svg.call(this.zoom);
                
                // 当前数据和样式
                this.currentData = null;
                this.currentStyle = 'tree';
                
                // 绑定窗口大小变化事件
                window.addEventListener('resize', () => {
                    this.updateDimensions();
                    if (this.currentData) {
                        this.render(this.currentData, this.currentStyle);
                    }
                });
            }
            
            updateDimensions() {
                const containerRect = this.container.node().getBoundingClientRect();
                this.width = containerRect.width;
                this.height = containerRect.height;
                
                this.svg
                    .attr('width', this.width)
                    .attr('height', this.height);
            }
            
            // 渲染可视化
            render(data, style = 'tree') {
                this.currentData = data;
                this.currentStyle = style;
                
                // 清除现有内容
                this.mainGroup.selectAll('*').remove();
                
                switch (style) {
                    case 'tree':
                        this.renderTree(data);
                        break;
                    case 'network':
                        this.renderNetwork(data);
                        break;
                    case 'radial':
                        this.renderRadial(data);
                        break;
                    default:
                        console.error('Unknown visualization style:', style);
                }
            }
            
            // 渲染树状图
            renderTree(data) {
                const treeLayout = d3.tree()
                    .size([this.width - 100, this.height - 100]);
                
                // 构建层次结构
                const root = this.buildHierarchy(data);
                const treeData = treeLayout(root);
                
                // 渲染连线
                this.mainGroup.selectAll('.link')
                    .data(treeData.links())
                    .enter()
                    .append('path')
                    .attr('class', 'link')
                    .attr('d', d3.linkHorizontal()
                        .x(d => d.y + 50)
                        .y(d => d.x + 50)
                    );
                
                // 渲染节点
                const nodes = this.mainGroup.selectAll('.node')
                    .data(treeData.descendants())
                    .enter()
                    .append('g')
                    .attr('class', 'node-group')
                    .attr('transform', d => `translate(${d.y + 50}, ${d.x + 50})`);
                
                // 添加节点圆圈
                nodes.append('circle')
                    .attr('class', d => `node ${d.data.claim_type}`)
                    .attr('r', d => d.data.claim_type === 'independent' ? 20 : 15)
                    .on('mouseover', (event, d) => this.showTooltip(event, d.data))
                    .on('mouseout', () => this.hideTooltip())
                    .on('click', (event, d) => this.onNodeClick(d.data));
                
                // 添加节点标签
                nodes.append('text')
                    .attr('class', 'node-label')
                    .attr('dy', '0.35em')
                    .text(d => d.data.claim_number);
            }
            
            // 渲染网络图
            renderNetwork(data) {
                const simulation = d3.forceSimulation(data.nodes)
                    .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2));
                
                // 渲染连线
                const links = this.mainGroup.selectAll('.link')
                    .data(data.links)
                    .enter()
                    .append('line')
                    .attr('class', 'link');
                
                // 渲染节点
                const nodes = this.mainGroup.selectAll('.node-group')
                    .data(data.nodes)
                    .enter()
                    .append('g')
                    .attr('class', 'node-group')
                    .call(d3.drag()
                        .on('start', (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on('drag', (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on('end', (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        })
                    );
                
                // 添加节点圆圈
                nodes.append('circle')
                    .attr('class', d => `node ${d.claim_type}`)
                    .attr('r', d => d.claim_type === 'independent' ? 20 : 15)
                    .on('mouseover', (event, d) => this.showTooltip(event, d))
                    .on('mouseout', () => this.hideTooltip())
                    .on('click', (event, d) => this.onNodeClick(d));
                
                // 添加节点标签
                nodes.append('text')
                    .attr('class', 'node-label')
                    .attr('dy', '0.35em')
                    .text(d => d.claim_number);
                
                // 更新位置
                simulation.on('tick', () => {
                    links
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    nodes.attr('transform', d => `translate(${d.x}, ${d.y})`);
                });
            }
            
            // 渲染径向图
            renderRadial(data) {
                const radius = Math.min(this.width, this.height) / 2 - 50;
                const tree = d3.cluster().size([2 * Math.PI, radius]);
                
                // 构建层次结构
                const root = this.buildHierarchy(data);
                const treeData = tree(root);
                
                // 移动到中心
                this.mainGroup.attr('transform', `translate(${this.width / 2}, ${this.height / 2})`);
                
                // 渲染连线
                this.mainGroup.selectAll('.link')
                    .data(treeData.links())
                    .enter()
                    .append('path')
                    .attr('class', 'link')
                    .attr('d', d3.linkRadial()
                        .angle(d => d.x)
                        .radius(d => d.y)
                    );
                
                // 渲染节点
                const nodes = this.mainGroup.selectAll('.node-group')
                    .data(treeData.descendants())
                    .enter()
                    .append('g')
                    .attr('class', 'node-group')
                    .attr('transform', d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y}, 0)`);
                
                // 添加节点圆圈
                nodes.append('circle')
                    .attr('class', d => `node ${d.data.claim_type}`)
                    .attr('r', d => d.data.claim_type === 'independent' ? 20 : 15)
                    .on('mouseover', (event, d) => this.showTooltip(event, d.data))
                    .on('mouseout', () => this.hideTooltip())
                    .on('click', (event, d) => this.onNodeClick(d.data));
                
                // 添加节点标签
                nodes.append('text')
                    .attr('class', 'node-label')
                    .attr('dy', '0.35em')
                    .attr('x', d => d.x < Math.PI === !d.children ? 6 : -6)
                    .attr('text-anchor', d => d.x < Math.PI === !d.children ? 'start' : 'end')
                    .attr('transform', d => d.x >= Math.PI ? 'rotate(180)' : null)
                    .text(d => d.data.claim_number);
            }
            
            // 构建D3层次结构
            buildHierarchy(data) {
                // 找到根节点
                const rootNodes = data.nodes.filter(node => 
                    !data.links.some(link => link.target === node.id)
                );
                
                if (rootNodes.length === 0) {
                    // 如果没有明确的根节点，使用第一个独立权利要求
                    const independentClaim = data.nodes.find(node => node.claim_type === 'independent');
                    if (independentClaim) {
                        rootNodes.push(independentClaim);
                    } else {
                        rootNodes.push(data.nodes[0]);
                    }
                }
                
                // 构建层次结构
                const buildChildren = (nodeId) => {
                    const children = data.links
                        .filter(link => link.source === nodeId)
                        .map(link => {
                            const childNode = data.nodes.find(node => node.id === link.target);
                            return {
                                ...childNode,
                                children: buildChildren(childNode.id)
                            };
                        });
                    
                    return children.length > 0 ? children : null;
                };
                
                // 如果有多个根节点，创建虚拟根节点
                if (rootNodes.length > 1) {
                    return d3.hierarchy({
                        id: 'virtual_root',
                        claim_number: 'Root',
                        claim_type: 'independent',
                        children: rootNodes.map(root => ({
                            ...root,
                            children: buildChildren(root.id)
                        }))
                    });
                } else {
                    return d3.hierarchy({
                        ...rootNodes[0],
                        children: buildChildren(rootNodes[0].id)
                    });
                }
            }
            
            // 显示工具提示
            showTooltip(event, data) {
                const tooltip = this.tooltip;
                
                tooltip.html(`
                    <strong>权利要求 ${data.claim_number}</strong><br>
                    类型: ${data.claim_type === 'independent' ? '独立权利要求' : '从属权利要求'}<br>
                    ${data.dependencies && data.dependencies.length > 0 ? 
                        `依赖: ${data.dependencies.join(', ')}<br>` : ''}
                    层级: ${data.level || 0}<br>
                    <em>点击查看详细内容</em>
                `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
            }
            
            // 隐藏工具提示
            hideTooltip() {
                this.tooltip.style('opacity', 0);
            }
            
            // 节点点击事件
            onNodeClick(data) {
                alert(`权利要求 ${data.claim_number}\n\n${data.claim_text}`);
            }
            
            // 缩放控制
            zoomIn() {
                this.svg.transition().call(
                    this.zoom.scaleBy, 1.5
                );
            }
            
            zoomOut() {
                this.svg.transition().call(
                    this.zoom.scaleBy, 1 / 1.5
                );
            }
            
            zoomReset() {
                this.svg.transition().call(
                    this.zoom.transform,
                    d3.zoomIdentity
                );
            }
            
            centerView() {
                const bounds = this.mainGroup.node().getBBox();
                const fullWidth = this.width;
                const fullHeight = this.height;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;
                
                const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                
                this.svg.transition().call(
                    this.zoom.transform,
                    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
                );
            }
        }
        
        // 全局变量
        let renderer;
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 创建渲染器
            renderer = new D3TreeRenderer('visualizationContainer');
            
            // 渲染测试数据
            renderer.render(testData, 'tree');
        });
        
        // 切换可视化样式
        function switchStyle(style) {
            // 更新按钮状态
            document.querySelectorAll('.controls .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 渲染新样式
            renderer.render(testData, style);
        }
    </script>
</body>
</html>