# 功能八：独立重新处理模式 - 设计方案

## 📋 需求概述

支持两种独立的重新处理模式：

### 模式1：只重新处理说明书（保留OCR结果）
- **场景**：图片已OCR识别完成，但说明书内容有更新
- **操作**：用户重新上传说明书文本，使用已缓存的OCR结果进行匹配
- **优势**：无需重新OCR，节省时间，快速更新匹配结果

### 模式2：只重新OCR图片（保留说明书解析结果）
- **场景**：说明书已解析完成，但需要重新上传图片或调整OCR参数
- **操作**：用户重新上传图片，使用已缓存的说明书解析结果进行匹配
- **优势**：无需重新解析说明书，快速更新图片标注

---

## 🎯 技术方案

### 1. 后端API设计

#### 1.1 新增端点：`/drawing-marker/reprocess-specification`
**功能**：只重新处理说明书（保留OCR结果）

**请求参数**：
```json
{
  "cache_keys": ["drawing1.png_hash123", "drawing2.png_hash456"],
  "specification": "更新后的说明书内容",
  "ai_mode": true,
  "model_name": "glm-4-flash",
  "custom_prompt": "可选的自定义提示词"
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "drawings": [...],
    "reference_map": {...},
    "matched_count": 10,
    "ocr_detected_count": 12,
    "message": "✅ 使用缓存OCR结果 | 说明书重新解析 | 匹配: 10个"
  }
}
```

#### 1.2 新增端点：`/drawing-marker/reprocess-drawings`
**功能**：只重新OCR图片（保留说明书解析结果）

**请求参数**：
```json
{
  "drawings": [
    {
      "name": "drawing1.png",
      "type": "image/png",
      "size": 1024,
      "data": "base64encodeddata"
    }
  ],
  "reference_map": {
    "1": "底座",
    "2": "旋转臂"
  },
  "force_refresh": true
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "drawings": [...],
    "reference_map": {...},
    "matched_count": 10,
    "ocr_detected_count": 12,
    "message": "✅ 图片重新OCR识别 | 使用缓存说明书 | 匹配: 10个"
  }
}
```

---

### 2. 前端UI设计

#### 2.1 新增按钮位置
在功能八的主界面添加两个独立按钮：

```
┌─────────────────────────────────────┐
│  功能八：交互式附图标注              │
├─────────────────────────────────────┤
│  [上传图片] [上传说明书] [开始处理] │
│                                     │
│  ⚡ 快速重新处理：                  │
│  [🔄 重新识别图片标号]              │
│  [📝 重新处理说明书]                │
└─────────────────────────────────────┘
```

#### 2.2 按钮触发条件
- **显示条件**：已有缓存结果（OCR或说明书）
- **禁用条件**：
  - "重新识别图片标号"：无图片上传或无说明书缓存
  - "重新处理说明书"：无说明书上传或无OCR缓存

#### 2.3 用户交互流程

**流程1：重新识别图片标号**
```
1. 用户点击"重新识别图片标号"
2. 弹窗确认：
   "检测到说明书缓存，将使用已解析的说明书内容重新识别图片。
    是否继续？"
3. 用户确认后：
   - 显示进度条
   - 调用 /drawing-marker/reprocess-drawings
   - 使用缓存的reference_map
   - 重新OCR图片
4. 显示更新后的标注结果
```

**流程2：重新处理说明书**
```
1. 用户点击"重新处理说明书"
2. 弹窗确认：
   "检测到OCR缓存，将使用已识别的图片标记重新匹配说明书。
    是否继续？"
3. 用户确认后：
   - 显示进度条
   - 调用 /drawing-marker/reprocess-specification
   - 使用缓存的OCR结果
   - 重新解析说明书
4. 显示更新后的标注结果
```

---

### 3. 缓存管理优化

#### 3.1 缓存结构扩展
```javascript
{
  "cache_key": "drawing1.png_hash123",
  "timestamp": 1234567890,
  "ocr_results": [...],        // OCR识别结果
  "reference_map": {...},      // 说明书解析结果
  "specification_hash": "abc", // 说明书内容哈希
  "image_hash": "xyz"          // 图片内容哈希
}
```

#### 3.2 缓存键设计
- **OCR缓存键**：`ocr_{image_hash}`
- **说明书缓存键**：`spec_{specification_hash}`
- **完整结果缓存键**：`result_{image_hash}_{specification_hash}`

---

### 4. 实现步骤

#### 步骤1：后端实现（30分钟）
1. ✅ 在 `backend/routes/drawing_marker.py` 添加两个新端点
2. ✅ 扩展 `DrawingCacheManager` 支持分离缓存
3. ✅ 实现缓存查询和复用逻辑

#### 步骤2：前端实现（30分钟）
1. ✅ 在 `frontend/js/drawingMarkerInteractive_v8.js` 添加两个按钮
2. ✅ 实现按钮显示/隐藏逻辑
3. ✅ 实现确认弹窗和API调用
4. ✅ 更新缓存管理器支持分离缓存

#### 步骤3：测试验证（15分钟）
1. ✅ 测试"重新识别图片标号"流程
2. ✅ 测试"重新处理说明书"流程
3. ✅ 测试缓存失效场景

---

## 🎨 UI设计细节

### 按钮样式
```css
.reprocess-btn {
  padding: 10px 20px;
  border: 2px solid #2196F3;
  background-color: white;
  color: #2196F3;
  border-radius: 6px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
}

.reprocess-btn:hover {
  background-color: #2196F3;
  color: white;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
}

.reprocess-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

### 确认弹窗样式
```html
<div class="reprocess-confirm-modal">
  <div class="modal-icon">🔄</div>
  <h2>确认重新处理</h2>
  <p class="cache-info">
    检测到缓存：OCR识别 12个标记，说明书匹配 10个
  </p>
  <p class="warning">
    ⚠️ 此操作将使用缓存数据，确保缓存内容符合预期
  </p>
  <div class="button-group">
    <button class="cancel-btn">取消</button>
    <button class="confirm-btn">确认</button>
  </div>
</div>
```

---

## 📊 性能优化

### 优化点1：缓存命中率
- 使用内容哈希作为缓存键，确保相同内容复用缓存
- 缓存有效期：7天（可配置）

### 优化点2：处理速度
- **完整处理**：OCR (5-10s) + 说明书解析 (2-5s) = 7-15s
- **只重新处理说明书**：说明书解析 (2-5s) = 2-5s（节省70%时间）
- **只重新OCR图片**：OCR (5-10s) = 5-10s（节省30%时间）

### 优化点3：用户体验
- 显示缓存状态和时间
- 提供清晰的操作提示
- 支持一键切换模式

---

## 🔧 配置选项

### 后端配置
```python
# backend/config.py
DRAWING_CACHE_CONFIG = {
    'enable_cache': True,
    'cache_dir': 'cache/drawing_ocr',
    'max_age_days': 7,
    'enable_separate_cache': True  # 启用分离缓存
}
```

### 前端配置
```javascript
// frontend/js/config.js
const DRAWING_CONFIG = {
  enableReprocessButtons: true,
  showCacheInfo: true,
  confirmBeforeReprocess: true
};
```

---

## ✅ 验收标准

1. ✅ 用户可以在已有OCR缓存的情况下，只重新上传说明书并快速匹配
2. ✅ 用户可以在已有说明书缓存的情况下，只重新上传图片并快速标注
3. ✅ 按钮根据缓存状态自动显示/隐藏
4. ✅ 提供清晰的缓存信息和操作提示
5. ✅ 处理速度比完整流程快50%以上
6. ✅ 缓存失效时自动降级到完整处理流程

---

## 📝 后续优化

1. **缓存管理界面**：显示所有缓存，支持手动清除
2. **缓存统计**：显示缓存命中率、节省时间等
3. **批量重新处理**：支持批量图片的独立重新处理
4. **缓存同步**：支持跨设备缓存同步（可选）

---

## 🚀 立即开始实现

准备好了吗？让我们开始实现这个功能！

**预计总时间**：1.5小时
**优先级**：高
**复杂度**：中等
