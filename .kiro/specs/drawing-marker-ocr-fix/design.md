# 设计文档：专利附图标记识别修复

## 概述

本设计文档描述了专利附图标记识别功能（功能八）的修复方案。系统当前存在严重的OCR识别失败问题，主要原因是后端代码中存在变量引用错误，导致OCR识别结果无法正确返回。此外，前端使用硬编码的模拟数据而非真实API返回数据。

本次修复将：
1. 修正后端OCR识别逻辑中的变量引用错误
2. 优化图像预处理流程和OCR配置参数
3. 修复前端数据绑定，使用真实API返回数据
4. 实现Canvas标注功能，在附图上精确标注识别位置
5. 增强错误日志和调试信息
6. 改进说明书文本解析的鲁棒性

## 架构

### 系统组件

```
┌─────────────────────────────────────────────────────────────┐
│                         Frontend                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Image Upload │  │ Specification│  │   Canvas     │      │
│  │   Handler    │  │    Input     │  │  Annotator   │      │
│  └──────┬───────┘  └──────┬───────┘  └──────▲───────┘      │
│         │                  │                  │              │
│         └──────────┬───────┘                  │              │
│                    │                          │              │
│                    ▼                          │              │
│         ┌──────────────────────┐              │              │
│         │   API Client         │              │              │
│         └──────────┬───────────┘              │              │
└────────────────────┼──────────────────────────┼──────────────┘
                     │                          │
                     │ HTTP POST                │ Result Data
                     │                          │
┌────────────────────▼──────────────────────────┼──────────────┐
│                    Backend API                │              │
│  ┌─────────────────────────────────────────┐  │              │
│  │  /api/drawing-marker/process            │  │              │
│  └─────────────┬───────────────────────────┘  │              │
│                │                               │              │
│                ▼                               │              │
│  ┌─────────────────────────────────────────┐  │              │
│  │   Specification Text Parser             │  │              │
│  │   - Extract reference markers           │  │              │
│  │   - Build Reference_Map                 │  │              │
│  └─────────────┬───────────────────────────┘  │              │
│                │                               │              │
│                ▼                               │              │
│  ┌─────────────────────────────────────────┐  │              │
│  │   Image Processing Pipeline             │  │              │
│  │   ┌─────────────────────────────────┐   │  │              │
│  │   │  1. Decode Base64 Image         │   │  │              │
│  │   └─────────────┬───────────────────┘   │  │              │
│  │                 ▼                        │  │              │
│  │   ┌─────────────────────────────────┐   │  │              │
│  │   │  2. Image Preprocessing         │   │  │              │
│  │   │     - Grayscale                 │   │  │              │
│  │   │     - Adaptive Threshold        │   │  │              │
│  │   │     - Otsu Threshold            │   │  │              │
│  │   │     - Simple Threshold          │   │  │              │
│  │   └─────────────┬───────────────────┘   │  │              │
│  │                 ▼                        │  │              │
│  │   ┌─────────────────────────────────┐   │  │              │
│  │   │  3. OCR Recognition (Tesseract) │   │  │              │
│  │   │     - Run on each preprocessed  │   │  │              │
│  │   │     - Collect all results       │   │  │              │
│  │   │     - Deduplicate by position   │   │  │              │
│  │   └─────────────┬───────────────────┘   │  │              │
│  │                 ▼                        │  │              │
│  │   ┌─────────────────────────────────┐   │  │              │
│  │   │  4. Result Filtering            │   │  │              │
│  │   │     - Confidence threshold      │   │  │              │
│  │   │     - Pattern matching          │   │  │              │
│  │   │     - Reference map lookup      │   │  │              │
│  │   └─────────────┬───────────────────┘   │  │              │
│  │                 │                        │  │              │
│  └─────────────────┼────────────────────────┘  │              │
│                    │                            │              │
│                    ▼                            │              │
│  ┌─────────────────────────────────────────┐   │              │
│  │   Result Aggregator                     │   │              │
│  │   - Calculate match rate                │   │              │
│  │   - Generate statistics                 │   │              │
│  │   - Build response JSON                 │───┘              │
│  └─────────────────────────────────────────┘                  │
└────────────────────────────────────────────────────────────────┘
```

### 数据流

1. **上传阶段**：用户上传图片和输入说明书文本
2. **解析阶段**：后端解析说明书，提取Reference_Map
3. **预处理阶段**：对每张图片应用多种预处理方法
4. **识别阶段**：对每种预处理结果运行OCR识别
5. **合并阶段**：合并所有识别结果，去重并过滤
6. **匹配阶段**：将识别结果与Reference_Map匹配
7. **返回阶段**：计算统计信息并返回JSON响应
8. **标注阶段**：前端在Canvas上绘制识别结果

## 组件和接口

### 后端组件

#### 1. Specification Text Parser

**职责**：解析说明书文本，提取附图标记和部件名称的映射关系

**接口**：
```python
def extract_reference_markers(spec_text: str) -> Dict[str, str]:
    """
    提取附图标记映射关系
    
    Args:
        spec_text: 说明书文本内容
        
    Returns:
        Dict[str, str]: 标记编号到部件名称的映射
        例如: {"1": "底座", "2": "旋转臂", "3L": "左侧外壳"}
    """
```

**实现细节**：
- 支持多种格式的正则表达式模式
- 模式1：`数字[字母] + 分隔符(. 、) + 名称`
- 模式2：`数字[字母] + 中文字符`（无分隔符）
- 模式3：`数字[字母] + 空格 + 中文字符`
- 优先级：模式1 > 模式2 > 模式3（避免重复）

#### 2. Image Preprocessor

**职责**：对上传图片进行多种预处理，生成适合OCR识别的图像

**接口**：
```python
def preprocess_image(image: np.ndarray) -> List[np.ndarray]:
    """
    对图像进行多种预处理
    
    Args:
        image: OpenCV格式的原始图像
        
    Returns:
        List[np.ndarray]: 预处理后的图像列表
    """
```

**预处理方法**：
1. **Grayscale**: 灰度化，保留原始灰度信息
2. **Adaptive Threshold**: 自适应阈值，适合光照不均匀
3. **Otsu Threshold**: Otsu二值化，自动确定最佳阈值
4. **Simple Threshold**: 简单阈值（127），适合对比度高的图像

#### 3. OCR Engine Wrapper

**职责**：封装Tesseract OCR调用，提供统一的识别接口

**接口**：
```python
def recognize_numbers(
    image: np.ndarray,
    config: str = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
) -> List[Dict]:
    """
    使用Tesseract识别图像中的数字和字母
    
    Args:
        image: 预处理后的图像
        config: Tesseract配置参数
        
    Returns:
        List[Dict]: 识别结果列表，每项包含:
            - text: 识别的文本
            - x, y, width, height: 边界框坐标
            - confidence: 置信度 (0-100)
    """
```

**OCR配置说明**：
- `--oem 3`: 使用默认OCR引擎模式（LSTM神经网络）
- `--psm 6`: 页面分割模式6（假设单个统一文本块）
- `tessedit_char_whitelist`: 只识别数字0-9和大写字母A-Z

#### 4. Result Deduplicator

**职责**：去除重复的识别结果，保留置信度最高的

**接口**：
```python
def deduplicate_results(
    results: List[Dict],
    position_threshold: int = 20
) -> List[Dict]:
    """
    去除位置相近的重复识别结果
    
    Args:
        results: 原始识别结果列表
        position_threshold: 位置阈值（像素），小于此距离视为重复
        
    Returns:
        List[Dict]: 去重后的结果列表
    """
```

**去重逻辑**：
- 计算每个结果的中心点坐标
- 如果两个结果的中心点距离 < threshold 且文本相同，视为重复
- 保留置信度更高的结果

#### 5. Result Matcher

**职责**：将OCR识别结果与Reference_Map匹配

**接口**：
```python
def match_with_reference_map(
    detected_numbers: List[Dict],
    reference_map: Dict[str, str]
) -> Tuple[List[Dict], List[str], List[str]]:
    """
    匹配识别结果与参考映射
    
    Args:
        detected_numbers: OCR识别结果
        reference_map: 说明书中的标记映射
        
    Returns:
        Tuple包含:
        - matched_results: 匹配成功的结果（包含name字段）
        - unknown_markers: 识别到但未在说明书中定义的标记
        - missing_markers: 说明书中定义但未识别到的标记
    """
```

### 前端组件

#### 1. Canvas Annotator

**职责**：在Canvas上绘制识别结果的标注

**接口**：
```javascript
function annotateDrawing(canvas, imageUrl, detectedNumbers, scaleFactor) {
    /**
     * 在Canvas上标注识别结果
     * 
     * @param {HTMLCanvasElement} canvas - Canvas元素
     * @param {string} imageUrl - 图片URL
     * @param {Array} detectedNumbers - 识别结果数组
     * @param {number} scaleFactor - 坐标缩放因子
     */
}
```

**标注样式**：
- 红色圆圈标记数字位置（半径10px）
- 白色边框（2px）提高可见度
- 圆圈旁显示数字和部件名称
- 悬停时显示详细信息（数字、名称、置信度）

#### 2. Result Display Manager

**职责**：管理处理结果的显示

**接口**：
```javascript
function displayProcessingResult(data) {
    /**
     * 显示处理结果
     * 
     * @param {Object} data - API返回的数据对象
     * @param {Array} data.drawings - 处理后的图片数组
     * @param {Object} data.reference_map - 参考映射
     * @param {number} data.total_numbers - 识别总数
     * @param {number} data.match_rate - 匹配率
     * @param {string} data.message - 处理消息
     */
}
```

## 数据模型

### API请求格式

```json
{
  "drawings": [
    {
      "name": "drawing1.png",
      "type": "image/png",
      "size": 102400,
      "data": "base64encodeddata..."
    }
  ],
  "specification": "1. 底座\n2. 旋转臂\n3L. 左侧外壳"
}
```

### API响应格式

```json
{
  "success": true,
  "data": {
    "drawings": [
      {
        "name": "drawing1.png",
        "type": "image/png",
        "size": 102400,
        "detected_numbers": [
          {
            "number": "1",
            "name": "底座",
            "x": 150,
            "y": 200,
            "width": 25,
            "height": 30,
            "confidence": 92
          }
        ]
      }
    ],
    "reference_map": {
      "1": "底座",
      "2": "旋转臂",
      "3L": "左侧外壳"
    },
    "total_numbers": 1,
    "match_rate": 33.33,
    "matched_count": 1,
    "unknown_markers": [],
    "missing_markers": ["2", "3L"],
    "message": "成功处理 1 张图片，识别出 1 个数字序号，匹配率 33.33%",
    "suggestions": [
      "匹配率较低，建议检查图片清晰度",
      "缺失标记: 2, 3L"
    ]
  }
}
```

### 内部数据结构

#### DetectedNumber

```python
{
    "number": str,        # 识别的数字/标记，如 "1", "3L"
    "name": str,          # 对应的部件名称（如果匹配）
    "x": int,             # 中心点X坐标
    "y": int,             # 中心点Y坐标
    "width": int,         # 边界框宽度
    "height": int,        # 边界框高度
    "confidence": int     # 置信度 (0-100)
}
```

## 正确性属性

*属性是一个特征或行为，应该在系统的所有有效执行中保持为真——本质上是关于系统应该做什么的正式陈述。属性作为人类可读规范和机器可验证正确性保证之间的桥梁。*

### 属性反思

在分析了所有验收标准后，我识别出以下可以合并或简化的属性：

**合并的属性**：
- 需求6.1-6.4（支持不同格式）可以合并为一个综合属性：文本解析器应该支持所有定义的格式
- 需求3.1-3.3（前端显示不同字段）可以合并为一个属性：前端应该正确显示所有API返回的数据字段
- 需求5.1-5.4（不同场景的日志记录）是具体示例，不需要单独的属性

**去除的冗余**：
- 需求1.1和1.2是代码实现细节，不是功能性属性
- 需求2.1和2.2是配置检查，作为示例测试更合适

### 核心属性

**属性 1：去重保留最高置信度**

*对于任何*识别结果集合，如果存在位置相近（距离<20像素）且数字相同的多个结果，系统应该只保留置信度最高的那个结果。

**验证：需求 1.3**

---

**属性 2：异常容错性**

*对于任何*预处理方法，如果OCR识别过程中发生异常，系统应该记录错误日志并继续处理其他预处理方法，最终返回所有成功方法的合并结果。

**验证：需求 1.4, 1.5**

---

**属性 3：置信度过滤**

*对于任何*识别结果集合，所有返回给用户的结果的置信度都应该大于或等于60。

**验证：需求 2.3**

---

**属性 4：字母后缀标记识别**

*对于任何*包含数字+字母组合的标记（如"3L"、"2R"），OCR系统应该将其识别为完整的单个标记，而不是分离的数字和字母。

**验证：需求 2.4**

---

**属性 5：图像尺寸自适应**

*对于任何*输入图像，无论其原始尺寸如何，预处理器应该将其调整到最佳识别尺寸范围（宽度或高度在800-2000像素之间），以提高OCR准确率。

**验证：需求 2.5**

---

**属性 6：前端数据绑定正确性**

*对于任何*API返回的处理结果，前端应该正确显示所有关键字段（total_numbers、match_rate、message），而不是使用硬编码的模拟数据。

**验证：需求 3.1, 3.2, 3.3**

---

**属性 7：Canvas标注完整性**

*对于任何*识别结果集合，Canvas上绘制的标记点数量应该等于detected_numbers数组的长度，且每个标记点的位置应该根据坐标缩放比例正确计算。

**验证：需求 3.4, 4.1, 4.5**

---

**属性 8：Canvas标注内容完整性**

*对于任何*标记点，Canvas上应该显示数字序号和对应的部件名称（如果匹配成功），且文本应该清晰可读。

**验证：需求 4.3**

---

**属性 9：说明书文本解析通用性**

*对于任何*符合以下格式之一的说明书文本，系统应该正确提取附图标记：
- "数字[字母] + 分隔符(. 、) + 名称"
- "数字[字母] + 中文字符"
- "数字[字母] + 空格 + 中文字符"

且当多种格式混合时，应该提取所有标记并避免重复。

**验证：需求 6.1, 6.2, 6.3, 6.4, 6.5**

---

**属性 10：统计信息完整性**

*对于任何*处理结果，API响应应该包含完整的统计信息：total_numbers（识别总数）、match_rate（匹配率）、matched_count（匹配数量）、unknown_markers（未知标记列表）、missing_markers（缺失标记列表）。

**验证：需求 7.1**

---

**属性 11：低匹配率建议**

*对于任何*处理结果，如果match_rate < 50%，响应应该在suggestions字段中包含改进建议。

**验证：需求 7.2**

---

**属性 12：未知标记识别**

*对于任何*识别到的数字，如果该数字不在reference_map中，系统应该将其添加到unknown_markers列表中。

**验证：需求 7.3**

---

**属性 13：缺失标记检测**

*对于任何*reference_map中的标记，如果该标记未在任何图片中被识别到，系统应该将其添加到missing_markers列表中。

**验证：需求 7.4**

---

**属性 14：低置信度建议**

*对于任何*处理结果，如果所有识别结果的平均置信度低于70，响应应该在suggestions字段中建议用户提供更清晰的图片。

**验证：需求 7.5**

## 错误处理

### 错误类型和处理策略

#### 1. 输入验证错误

**场景**：
- 未上传图片（drawings为空）
- 未输入说明书内容（specification为空）
- 图片格式不支持
- Base64解码失败

**处理**：
- 返回HTTP 400错误
- 提供清晰的错误消息
- 不进行任何处理

#### 2. OCR识别错误

**场景**：
- Tesseract未安装或配置错误
- 图像格式转换失败
- 单个预处理方法OCR失败

**处理**：
- 记录详细错误日志（包括堆栈信息）
- 继续处理其他预处理方法
- 如果所有方法都失败，返回空结果但不报错
- 在响应中添加警告信息

#### 3. 说明书解析错误

**场景**：
- 说明书格式不规范
- 无法提取任何标记

**处理**：
- 记录警告日志
- 返回空的reference_map
- 在响应中提示用户检查说明书格式

#### 4. 系统错误

**场景**：
- 内存不足
- 文件系统错误
- 未预期的异常

**处理**：
- 记录完整错误堆栈
- 返回HTTP 500错误
- 提供通用错误消息（不暴露内部细节）

### 错误响应格式

```json
{
  "success": false,
  "error": "错误消息",
  "error_code": "ERROR_CODE",
  "details": {
    "field": "具体字段",
    "reason": "详细原因"
  }
}
```

### 日志级别

- **DEBUG**: OCR识别详细信息、预处理参数
- **INFO**: 处理开始/完成、统计信息
- **WARNING**: 说明书解析问题、低匹配率
- **ERROR**: OCR异常、系统错误

## 测试策略

### 双重测试方法

本项目采用单元测试和属性测试相结合的方法：

**单元测试**：
- 验证具体示例和边缘情况
- 测试错误条件和异常处理
- 验证配置和集成点
- 重点关注：
  - 特定格式的说明书解析示例
  - 空输入、无效输入的边缘情况
  - OCR异常的错误处理
  - 前端UI元素的存在性检查

**属性测试**：
- 验证跨所有输入的通用属性
- 通过随机化实现全面的输入覆盖
- 重点关注：
  - 去重逻辑的正确性
  - 置信度过滤的一致性
  - 坐标缩放计算的准确性
  - 统计信息的完整性

### 属性测试配置

**测试库选择**：
- **Python后端**: Hypothesis
- **JavaScript前端**: fast-check

**配置要求**：
- 每个属性测试最少运行100次迭代
- 每个测试必须引用设计文档中的属性
- 标签格式：`# Feature: drawing-marker-ocr-fix, Property {number}: {property_text}`

### 测试覆盖范围

#### 后端测试

**单元测试**：
1. 说明书解析器测试
   - 测试各种格式的示例输入
   - 测试空输入和无效输入
   - 测试混合格式

2. 图像预处理测试
   - 验证生成4种预处理图像
   - 测试极端尺寸的图像

3. OCR配置测试
   - 验证Tesseract配置字符串正确

4. 错误处理测试
   - 模拟OCR异常
   - 验证日志记录

**属性测试**：
1. 去重属性（属性1）
2. 异常容错属性（属性2）
3. 置信度过滤属性（属性3）
4. 字母后缀识别属性（属性4）
5. 图像尺寸自适应属性（属性5）
6. 说明书解析通用性属性（属性9）
7. 统计信息完整性属性（属性10）
8. 低匹配率建议属性（属性11）
9. 未知标记识别属性（属性12）
10. 缺失标记检测属性（属性13）
11. 低置信度建议属性（属性14）

#### 前端测试

**单元测试**：
1. API客户端测试
   - 测试请求格式正确
   - 测试响应解析

2. UI元素测试
   - 验证结果显示区域存在
   - 验证Canvas元素创建

3. 边缘情况测试
   - 测试空结果显示
   - 测试错误消息显示

**属性测试**：
1. 前端数据绑定属性（属性6）
2. Canvas标注完整性属性（属性7）
3. Canvas标注内容属性（属性8）

### 集成测试

**端到端测试场景**：
1. 完整流程测试：上传图片 → 输入说明书 → 处理 → 显示结果
2. 多图片测试：同时处理多张图片
3. 复杂说明书测试：包含多种格式的说明书
4. 低质量图片测试：模糊、低分辨率图片
5. 错误恢复测试：部分图片失败时的处理

### 测试数据

**测试图片集**：
- 高质量专利附图（清晰、高分辨率）
- 低质量图片（模糊、低分辨率）
- 不同尺寸的图片（小、中、大）
- 包含不同数量标记的图片（1-50个）
- 包含字母后缀标记的图片（如3L、2R）

**测试说明书文本**：
- 标准格式："1. 底座\n2. 旋转臂"
- 无分隔符格式："1电动工具2外壳"
- 字母后缀格式："2L左侧外壳3R右侧外壳"
- 混合格式
- 空文本和无效文本

